have step₁ : m = 2 ∧ n = 2 := by
    have h₄ := h₀.1
    have h₅ := h₀.2
    have h₆ := h₂
    have h₇ := h₃
    have h₈ := h₄.eq_two_or_odd
    have h₉ := h₅.eq_two_or_odd
    have h₁₀ := h₆
    have h₁₁ := h₇
    have h₁₂ : (k : ℤ) ^ 2 - m * k + n = 0 := by exact_mod_cast h₂
    have h₁₃ : (t : ℤ) ^ 2 - m * t + n = 0 := by exact_mod_cast h₃
    norm_num at h₈ h₉ h₁₂ h₁₃ ⊢
    have h₁₄ : m ≤ 5 := by
      by_contra! h
      have h₁₅ : m ≥ 6 := by linarith
      nlinarith [sq_nonneg (k : ℤ), sq_nonneg (t : ℤ), sq_nonneg (m : ℤ),
        sq_nonneg (k - m / 2 : ℤ), sq_nonneg (t - m / 2 : ℤ)]
    have h₁₅ : n ≤ 5 := by
      by_contra! h
      have h₁₆ : n ≥ 6 := by linarith
      nlinarith [sq_nonneg (k : ℤ), sq_nonneg (t : ℤ), sq_nonneg (m : ℤ),
        sq_nonneg (k - m / 2 : ℤ), sq_nonneg (t - m / 2 : ℤ)]
    interval_cases m <;> interval_cases n <;> norm_num at h₈ h₉ h₁₂ h₁₃ ⊢ <;>
      (try omega) <;>
      (try {
        have h₁₆ : (k : ℤ) ≤ 10 := by
          nlinarith
        have h₁₇ : (t : ℤ) ≤ 10 := by
          nlinarith
        have h₁₈ : t < k := by omega
        interval_cases k <;> interval_cases t <;> omega
      }) <;>
      (try omega) <;>
      (try {
        simp_all [Nat.Prime] <;>
        omega
      }) <;>
      aesop
  
  have step₂ : m = 2 ∧ n = 2 := by
    exact step₁
  have step₃ : m ^ n + n ^ m + k ^ t + t ^ k = 20 := by
    rcases step₂ with ⟨rfl, rfl⟩
    have h₄ : k > t := h₁
    have h₆ : (t : ℤ) ^ 2 - 2 * t + 2 = 0 := by
      ring_nf at *
      <;> norm_cast at * <;> nlinarith
    have h₇ : t = 1 := by
      have : t ≤ 1 := by
        nlinarith [sq_nonneg (t : ℤ), sq_nonneg (t - 1 : ℤ)]
      interval_cases t <;> norm_num at h₆ ⊢ <;> omega
    have h₈ : k = 2 := by
      nlinarith
    simp_all
    <;> norm_num
    <;> aesop
  
  exact step₃
```