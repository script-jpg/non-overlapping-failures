-- proof by contradiction
  by_contra h

  -- use integer arithmetic
  have h1 : 4 * x ^ 3 - 7 * y ^ 3 ≡ 2003 [ZMOD 7] := congrFun (congrArg HMod.hMod h) 7

  -- simplify
  have h2 : 4 * x ^ 3 ≡ 2003 [ZMOD 7] := Int.ModEq.add_right_cancel' (-7 * y ^ 3) h1

  -- unfold [ZMOD]
  unfold Int.ModEq at h2
  simp at h2

  -- use modular arithmetic
  have h3 : x ^ 3 % 7 = 0 ∨ x ^ 3 % 7 = 1 ∨ x ^ 3 % 7 = 6 := by
    have h3 : x % 7 = 0 ∨ x % 7 = 1 ∨ x % 7 = 2 ∨ x % 7 = 3 ∨ x % 7 = 4 ∨ x % 7 = 5 ∨ x % 7 = 6 := by
      omega
    rcases h3 with (h3 | h3 | h3 | h3 | h3 | h3 | h3)
    · omega
    · left; rw [← pow_three, Int.mul_emod, h3]; omega
    · right; right; rw [← pow_three, Int.mul_emod, h3]; omega
    · right; left; rw [← pow_three, Int.mul_emod, h3]; omega
    · right; right; rw [← pow_three, Int.mul_emod, h3]; omega
    · right; right; rw [← pow_three, Int.mul_emod, h3]; omega
    · right; left; rw [← pow_three, Int.mul_emod, h3]; omega

  -- simplify
  have h4 : (4 * x ^ 3) % 7 = 2003 % 7 := by omega
  have h5 : (4 * x ^ 3) % 7 = 4 ∨ (4 * x ^ 3) % 7 = 5 ∨ (4 * x ^ 3) % 7 = 2 := by
    rcases h3 with (h3 | h3 | h3)
    · omega
    · omega
    · omega

  -- use modular arithmetic
  have h6 : 2003 % 7 = 2003 % 7 := rfl
  rw [← h4, h6] at h2
  rcases h5 with (h5 | h5 | h5)
  all_goals omega
```