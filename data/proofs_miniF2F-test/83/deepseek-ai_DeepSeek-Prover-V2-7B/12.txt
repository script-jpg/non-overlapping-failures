have h₁ : ∀ k : ℕ, k ∈ Finset.Icc 1 n → (1 : ℝ) + 1 / 2 ^ k ≤ 2 := by
    intro k hk
    have hk' : k ≥ 1 := (Finset.mem_Icc.mp hk).1
    have hk'' : (k : ℝ) ≥ 1 := by exact_mod_cast hk'
    have h : (1 : ℝ) / 2 ^ k ≤ 1 := by
      apply div_le_one_of_le
      · exact one_le_pow_of_one_le (by norm_num) k
      · positivity
    linarith
  calc
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / 2 ^ k) ≤ ∏ k in Finset.Icc 1 n, 2 := Finset.prod_le_prod (fun k _ ↦ by
      linarith [h₁ k ‹_›]) (fun k hk ↦ by linarith [h₁ k hk])
    _ = 2 ^ n := by simp [Finset.prod_const]
    _ < 5 / 2 := by
      have h₂ : (2 : ℝ) ^ n < 5 / 2 := by
        have h₃ : n ≥ 1 := by linarith
        have h₄ : (2 : ℝ) ^ n ≥ 2 ^ 1 := by exact pow_le_pow_right (by norm_num) (by linarith)
        have h₅ : (2 : ℝ) ^ 1 = 2 := by norm_num
        have h₆ : (2 : ℝ) ^ n < 5 / 2 := by
          have h₇ : n < 3 := by
            by_contra h
            have h₈ : n ≥ 3 := by linarith
            have h₉ : (2 : ℝ) ^ n ≥ 2 ^ 3 := by exact pow_le_pow_right (by norm_num) (by linarith)
            have h₁₀ : (2 : ℝ) ^ 3 = 8 := by norm_num
            have h₁₁ : (8 : ℝ) > 5 / 2 := by norm_num
            linarith
          interval_cases n <;> norm_num at h₁ h₄ h₅ ⊢ <;> linarith
        exact h₆
      exact by linarith
  <;> norm_num
  <;> linarith
```