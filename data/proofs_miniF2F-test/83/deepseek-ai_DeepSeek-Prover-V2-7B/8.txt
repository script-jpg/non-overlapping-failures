have h₁ : ∀ k : ℕ, k ∈ Finset.Icc 1 n → (1 : ℝ) + 1 / 2 ^ k ≤ 2 := by
    intro k hk
    have hk' : k ≥ 1 := by simp_all [Finset.mem_Icc]
    have h : (2 : ℝ) ^ k ≥ 2 ^ 1 := by
      apply pow_le_pow_right (by norm_num)
      linarith
    have h' : (1 : ℝ) / 2 ^ k ≤ 1 := by
      apply (div_le_iff (by positivity)).mpr
      have : (2 : ℝ) ^ k ≥ 1 := by
        apply one_le_pow_of_one_le (by norm_num) k
      nlinarith
    nlinarith
  calc
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / 2 ^ k) ≤ ∏ k in Finset.Icc 1 n, 2 := by
      apply Finset.prod_le_prod
      · intro i hi
        positivity
      · intro i hi
        exact h₁ i hi
    _ = 2 ^ n := by
      simp [Finset.prod_const]
    _ < 5 / 2 := by
      norm_num
      have h₂ : (2 : ℝ) ^ n < 5 / 2 := by
        have h₃ : n ≥ 1 := by linarith
        have h₄ : (2 : ℝ) ^ n ≥ 2 ^ 1 := by
          apply pow_le_pow_right (by norm_num)
          linarith
        have h₅ : (2 : ℝ) ^ 1 = 2 := by norm_num
        have h₆ : (2 : ℝ) ^ n < 5 / 2 := by
          have : (2 : ℝ) ^ n < 5 / 2 := by
            have : n < 3 := by
              by_contra! h
              have : n ≥ 3 := by linarith
              have : (2 : ℝ) ^ n ≥ 2 ^ 3 := by
                exact pow_le_pow_right (by norm_num) (by linarith)
              norm_num at *
              nlinarith
            interval_cases n <;> norm_num at * <;> nlinarith
          linarith
        linarith
      linarith
```