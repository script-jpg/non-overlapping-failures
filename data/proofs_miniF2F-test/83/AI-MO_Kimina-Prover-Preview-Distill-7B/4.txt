-- lemma, induction base. 1 + 1 / 2 < 3 / 2.
  have l1 : 1 + (1 : ℝ) / 2 < 3 / 2 := by linarith

  -- lemma, induction step. 1 + (1 : ℝ) / 2 ^ (n + 1) ≤ 1 + (1 : ℝ) / 2 ^ n.
  have l2 : ∀ n : ℕ, 1 + (1 : ℝ) / 2 ^ (n + 1) ≤ 1 + (1 : ℝ) / 2 ^ n := by
    intro n
    have : (2 : ℝ) ^ (n + 1) = 2 * 2 ^ n := by exact Nat.two_pow (n + 1)
    rw [this]
    have : 0 < (2 : ℝ) ^ n := by exact Nat.pos_pow_of_pos 2 n
    have : 0 < 2 * (2 : ℝ) ^ n := by exact Nat.cast_pos.2 <| Nat.mul_pos (by norm_num) this
    have : (1 : ℝ) / (2 * (2 : ℝ) ^ n) ≤ (1 : ℝ) / (2 ^ n) := by
      apply one_div_le_one_div_of_le
      norm_num
      norm_num
      exact Nat.cast_two_mul_le_pow_succ n
    linarith

  induction n with
  | zero => linarith
  | succ n ih =>
    case base =>
      linarith
    | succ =>
      have : ∏ k ∈ Finset.Icc 1 (n + 1), 1 + (1 : ℝ) / 2 ^ k = (∏ k ∈ Finset.Icc 1 n, 1 + (1 : ℝ) / 2 ^ k) * (1 + (1 : ℝ) / 2 ^ (n + 1)) := by
        rw [Finset.prod_Icc_succ_top (Nat.one_le_iff_ne_zero.mpr h₀)]
        have : n + 1 + 1 = (n + 1) + 1 := by exact rfl
        rw [this]
        have : (1 : ℝ) / 2 ^ (n + 1 + 1) = (1 : ℝ) / 2 ^ (n + 1) * (1 / 2) := by
          have : (2 : ℝ) ^ (n + 1 + 1) = 2 * 2 ^ (n + 1) := by exact Nat.two_pow_succ (n + 1)
          rw [this]
          have : 0 < (2 : ℝ) ^ (n + 1) := by exact Nat.pos_pow_of_pos 2 (n + 1)
          have : 0 < (2 : ℝ) ^ (n + 1) * 2 := by exact Nat.cast_pos.2 <| Nat.mul_pos (by norm_num) this
          have : (1 : ℝ) / (2 * (2 : ℝ) ^ (n + 1)) = (1 / 2 * (1 : ℝ)) / (2 ^ (n + 1)) := by
            rw [div_mul_eq_div_div]
            norm_num
            exact Nat.cast_two_mul_le_pow_succ (n + 1)
          rw [this]
          have : (1 : ℝ) / 2 ^ (n + 1) = (1 : ℝ) / (2 ^ (n + 1)) := by simp
          rw [this]
          group
        rw [this]
        have : 1 + (1 : ℝ) / 2 ^ (n + 1 + 1) = 1 + (1 : ℝ) / (2 ^ (n + 1) * 2) := by
          rw [pow_succ]
          nth_rw 1 [← mul_one (1 / 2 ^ (n + 1))]
          rw [← this]
        rw [this]
      rw [this]
      apply mul_lt_mul_of_pos_right
      exact ih
      exact l2 n
      have : 0 < 1 + (1 : ℝ) / 2 ^ (n + 1) := by
        have : 0 < (1 : ℝ) / 2 ^ (n + 1) := by
          apply div_pos
          norm_num
          apply pow_pos
          norm_num
        linarith
      linarith

```