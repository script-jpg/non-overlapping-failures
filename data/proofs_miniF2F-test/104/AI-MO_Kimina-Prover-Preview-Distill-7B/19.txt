have pge3 : 3 ≤ p := by linarith

  have pmod3 : p ≡ 1 [MOD 3] ∨ p ≡ 2 [MOD 3] := by
    have h := Nat.mod_three_eq_or_eq_two_add_one p
    rcases h with (h | h)
   . left; exact h
   . right; exact h

  have not3divp : ¬3 ∣ p := by
    have h : 3 < p := by linarith
    have h' := Nat.Prime.coprime_iff_not_dvd h₀ h
    rw [Nat.coprime_comm] at h'
    exact h'

  have pmod4 : p ≡ 1 [MOD 4] ∨ p ≡ 3 [MOD 4] := by
    have h := Nat.mod_four_eq_or_eq_add_one_or_eq_add_two_or_eq_three p
    rcases h with (h | h | h | h)
   . left; exact h
   . right; right; left; exact h
   . right; right; right; exact h
   . right; left; exact h

  have not2divp : ¬2 ∣ p := by
    have h : 2 < p := by linarith
    have h' := Nat.Prime.coprime_iff_not_dvd h₀ h
    rw [Nat.coprime_comm] at h'
    exact h'

  have pge2 : 2 ≤ p := by linarith

  have pmod2 : p ≡ 1 [MOD 2] ∨ p ≡ 0 [MOD 2] := by
    have h := Nat.mod_two_eq_zero_or_one p
    rcases h with (h | h)
   . right; exact h
   . left; exact h

  have not1divp : ¬1 ∣ p := by
    have h : 1 < p := by linarith
    exact Nat.not_dvd_of_pos (by linarith) h

  have pmod6 : p ≡ 1 [MOD 6] ∨ p ≡ 5 [MOD 6] := by
    have h1 : p ≡ 1 [MOD 2] := by
      have h := Nat.mod_two_eq_zero_or_one p
      rcases h with (h | h)
     . right; exact h
     . left; exact h
    have h2 : p ≡ 1 [MOD 3] ∨ p ≡ 2 [MOD 3] := by
      have h := Nat.mod_three_eq_or_eq_two_add_one p
      rcases h with (h | h)
     . left; exact h
     . right; exact h
    have : p % 6 = 1 ∨ p % 6 = 5 := by
      mod_cases p % 2
      <;> mod_cases p % 3
      <;> omega
    rcases this with (h | h)
   . left; exact h
   . right; exact h

  have not6divp : ¬6 ∣ p := by
    have h : 6 ∣ p := by
      rcases pmod6 with (h | h)
     . exact h
     . exact h
    exact Nat.not_dvd_of_pos (by linarith) h

  have pmod8 : p ≡ 1 [MOD 8] ∨ p ≡ 3 [MOD 8] ∨ p ≡ 5 [MOD 8] ∨ p ≡ 7 [MOD 8] := by
    have h1 : p ≡ 1 [MOD 2] := by
      have h := Nat.mod_two_eq_zero_or_one p
      rcases h with (h | h)
     . right; exact h
     . left; exact h
    have h2 : p ≡ 1 [MOD 4] ∨ p ≡ 3 [MOD 4] := by
      have h := Nat.mod_four_eq_or_eq_add_one_or_eq_add_two_or_eq_three p
      rcases h with (h | h | h | h)
     . left; exact h
     . right; right; left; exact h
     . right; right; right; exact h
     . right; left; exact h
    have : p % 8 = 1 ∨ p % 8 = 3 ∨ p % 8 = 5 ∨ p % 8 = 7 := by
      mod_cases p % 2
      <;> mod_cases p % 4
      <;> omega
    rcases this with (h | h | h | h)
   . left; exact h
   . right; left; exact h
   . right; right; left; exact h
   . right; right; right; exact h

  have not8divp : ¬8 ∣ p := by
    have h : 8 ∣ p := by
      rcases pmod8 with (h | h | h | h)
     . exact h
     . exact h
     . exact h
     . exact h
    exact Nat.not_dvd_of_pos (by linarith) h

  have pmod12 : p ≡ 1 [MOD 12] ∨ p ≡ 5 [MOD 12] ∨ p ≡ 7 [MOD 12] ∨ p ≡ 11 [MOD 12] := by
    have h1 : p ≡ 1 [MOD 4] ∨ p ≡ 3 [MOD 4] := by
      have h := Nat.mod_four_eq_or_eq_add_one_or_eq_add_two_or_eq_three p
      rcases h with (h | h | h | h)
     . left; exact h
     . right; right; left; exact h
     . right; right; right; exact h
     . right; left; exact h
    have h2 : p ≡ 1 [MOD 3] ∨ p ≡ 2 [MOD 3] := by
      have h := Nat.mod_three_eq_or_eq_two_add_one p
      rcases h with (h | h)
     . left; exact h
     . right; exact h
    have : p % 12 = 1 ∨ p % 12 = 5 ∨ p % 12 = 7 ∨ p % 12 = 11 := by
      mod_cases p % 4
      <;> mod_cases p % 3
      <;> omega
    rcases this with (h | h | h | h)
   . left; exact h
   . right; left; exact h
   . right; right; left; exact h
   . right; right; right; exact h

  have not12divp : ¬12 ∣ p := by
    have h : 12 ∣ p := by
      rcases pmod12 with (h | h | h | h)
     . exact h
     . exact h
     . exact h
     . exact h
    exact Nat.not_dvd_of_pos (by linarith) h

  have pmod20 : p ≡ 1 [MOD 20] ∨ p ≡ 3 [MOD 20] ∨ p ≡ 7 [MOD 20] ∨ p ≡ 9 [MOD 20] ∨
      p ≡ 11 [MOD 20] ∨ p ≡ 13 [MOD 20] ∨ p ≡ 17 [MOD 20] ∨ p ≡ 19 [MOD 20] := by
    have h1 : p ≡ 1 [MOD 4] ∨ p ≡ 3 [MOD 4] := by
      have h := Nat.mod_four_eq_or_eq_add_one_or_eq_add_two_or_eq_three p
      rcases h with (h | h | h | h)
     . left; exact h
     . right; right; left; exact h
     . right; right; right; exact h
     . right; left; exact h
    have h2 : p ≡ 1 [MOD 5] ∨ p ≡ 2 [MOD 5] ∨ p ≡ 3 [MOD 5] ∨ p ≡ 4 [MOD 5] ∨ p ≡ 0 [MOD 5] := by
      have h := Nat.mod_five_eq_or_eq_add_one_or_eq_add_two_or_eq_add_three_or_eq_add_four p
      rcases h with (h | h | h | h | h)
     . left; exact h
     . right; left; exact h
     . right; right; left; exact h
     . right; right; right; left; exact h
     . right; right; right; right; exact h
    have : p % 20 = 1 ∨ p % 20 = 3 ∨ p % 20 = 7 ∨ p % 20 = 9 ∨ p % 20 = 11 ∨ p % 20 = 13 ∨ p % 20 = 17 ∨ p % 20 = 19 := by
      mod_cases p % 4
      <;> mod_cases p % 5
      <;> omega
    rcases this with (h | h | h | h | h | h | h | h)
   . left; exact h
   . right; left; exact h
   . right; right; left; exact h
   . right; right; right; left; exact h
   . right; right; right; right; left; exact h
   . right; right; right; right; right; exact h
   . right; right; right; right; right; right; left; exact h
   . right; right; right; right; right; right; right; exact h

  have not20divp : ¬20 ∣ p := by
    have h : 20 ∣ p := by
      rcases pmod20 with (h | h | h | h | h | h | h | h)
     . exact h
     . exact h
     . exact h
     . exact h
     . exact h
     . exact h
     . exact h
     . exact h
    exact Nat.not_dvd_of_pos (by linarith) h

  -- Theorem 1. $\sum_{k=1}^{p-2} k^{-1}(k+1)^{-1} \equiv 2 \pmod{p}$.
  have sumk_inv_mul_kplusone_inv_eq_two_modp : (∑ k in Finset.Icc 1 (p - 2), (k : ZMod p)⁻¹ * ((k : ZMod p) + 1)⁻¹) = 2 := by
    -- The sum can be telescoping.
    have sum_eq : ∑ k ∈ Finset.Icc 1 (p - 2), (k : ZMod p)⁻¹ * ((k : ZMod p) + 1)⁻¹ = 1 - (p - 1)⁻¹ := by
      -- The sum can be simplified by induction.
      induction n := Finset.Icc 1 (p - 2) with
      | empty => simpa using rfl
      | cons a ha IH =>
        rw [Finset.sum_Icc_succ_top, IH, Finset.sum_Icc_succ_top]
        simp [sub_add]
        rw [add_assoc, add_comm]
        norm_num
        rw [add_assoc, sub_add_cancel]
        simpa using by linarith
        rw [←ne_eq]
        intro x
        obtain (x | x) := x
       . contradiction
       . rw [←add_assoc, ←ZMod.val_add] at x
          norm_num at x
          rw [←val_eq_zero]
          exact Ne.symm (ZMod.ne_zero_iff_ne constants.val (a + 1))
    -- By Theorem 2, below, we have $1 - (p - 1)⁻¹ \equiv 2 \pmod{p}$.
    rw [sum_eq]
    have : 1 - (p - 1)⁻¹ = 2 := by
      -- By Theorem 2, below, we have $(p - 1)⁻¹ \equiv 1 - 2 \pmod{p}$.
      have invp_sub_one_eq_one_sub_two : (p - 1)⁻¹ = 1 - 2 := by
        -- Since $p$ is odd, $-1 \equiv (-1)^{\frac{p-1}{2}} \pmod{p}$ by Euler's criterion.
        have eq : (-1 : ZMod p) = (-1) ^ ((p - 1) / 2) := by
          have eq := ZMod.nthRoot_card_eq_pow_card_of_prime (by linarith) p
          rw [←eq]
          simpa using by linarith
        -- The Legendre symbol $\left(\frac{-1}{p}\right) = (-1)^{\frac{p-1}{2}}$.
        have legendre symbol_eq : legendreSym p (-1) = (-1) ^ ((p - 1) / 2) := by
          rw [legendreSym_eq_prod LegendreSym.left]
          have eq : p.Prime := h₀
          rw [ZMod.nthRoot_eq_iff_eq_pow_of_prime (by linarith) this (p - 1)]
          simp
        -- By the Legendre symbol, $(-1 \mid p) = (-1)^{\frac{p-1}{2}}$.
        have eq : (-1 : ZMod p) = (-1) ^ ((p - 1) / 2) := by
          have eq : legendreSym p (-1) = (-1) ^ ((p - 1) / 2) := by
            exact legendreSym_eq_prod LegendreSym.left
          rw [←eq]
          rw [legendreSym_eq LegendreSym.left]
          simp
        rw [←eq]
        -- Since $p \neq 2$, $p - 1$ is even.
        have evenp_sub_two : Even (p - 2) := by
          have h := Nat.Prime.odd_of_ne_two h₀ (by linarith)
          rw [←even_iff_two_dvd]
          exact even_iff_two_dvd.mp (Nat.sub_even_iff_left h)
        -- Since $p - 1$ is even, $(p - 1) / 2$ is an integer.
        have : (p - 1) / 2 = ((p - 1) / 2) := by
          -- This can be shown by division with remainder.
          omega
        rw [ZMod.val_one, this, ZMod.val_sub₀, ZMod.val_of_val_eq_zero, ZMod.val_one]
        rw [ZMod.eq_iff_modEq_nat, ZMod.eq_iff_modEq_nat, modEq_iff_dvd', dvd_iff_exists_eq_mul_right]
        use 1; use 2
        use (p - 1) / 2
        rw [mul_comm, mul_assoc, one_mul, two_mul]
        symm
        rw [←eq]
        -- The equation is satisfied.
        rw [←ZMod.val_add, ZMod.val_neg, ZMod.val_one, ZMod.val_one, ZMod.val_sub₀]
        simp
        rw [ZMod.eq_iff_modEq_nat, ZMod.eq_iff_modEq_nat, modEq_iff_dvd', dvd_iff_exists_eq_mul_right]
        use 1
        use p - 2
        rw [mul_comm, mul_assoc, one_mul, sub_eq_iff_eq_add]
        symm
        rw [ZMod.val_add, ZMod.val_neg, ZMod.val_one, ZMod.val_one, ZMod.val_sub₀]
        simp
        rw [ZMod.eq_iff_modEq_nat, ZMod.eq_iff_modEq_nat, modEq_iff_dvd', dvd_iff_exists_eq_mul_right]
        use 1
        use p - 2
        rw [mul_comm, mul_assoc, one_mul, sub_eq_iff_eq_add]
        symm
        rw [ZMod.val_add, ZMod.val_neg, ZMod.val_one, ZMod.val_one, ZMod.val_sub₀]
        simp
      rw [invp_sub_one_eq_one_sub_two]
      -- The equation is satisfied.
      symm
      rw [←ZMod.val_add, ZMod.val_one, ZMod.val_sub₀, ZMod.val_one, ZMod.val_neg]
      simp
      rw [ZMod.eq_iff_modEq_nat, ZMod.eq_iff_modEq_nat, modEq_iff_dvd', dvd_iff_exists_eq_mul_right]
      use 1
      use p - 2
      rw [mul_comm, mul_assoc, one_mul, sub_eq_iff_eq_add]
      symm
      rw [ZMod.val_add, ZMod.val_neg, ZMod.val_one, ZMod.val_one, ZMod.val_sub₀]
      simp
      rw [ZMod.eq_iff_modEq_nat, ZMod.eq_iff_modEq_nat, modEq_iff_dvd', dvd_iff_exists_eq_mul_right]
      use 1; use 2; use 1; use p - 2
      rw [mul_comm, mul_assoc, one_mul, sub_eq_iff_eq_add]
      symm
      rw [ZMod.val_add, ZMod.val_neg, ZMod.val_one, ZMod.val_one, ZMod.val_sub₀]
      simp
    -- The equation is satisfied.
    exact this

  exact sumk_inv_mul_kplusone_inv_eq_two_modp

  -- Theorem 2. $1 - (p - 1)⁻¹ \equiv 2 \pmod{p}$.
  have one_sub_invp_sub_one_eq_two_modp : 1 - (p - 1)⁻¹ = 2 := by
    -- The equation is satisfied.
    simpa using by linarith

  -- Theorem 3. $-1 \equiv (-1)^{\frac{p-1}{2}} \pmod{p}$.
  have neg_one_eq_neg_one_powfracp_sub_one : (-1 : ZMod p) = (-1) ^ ((p - 1) / 2) := by
    -- Since $p \neq 2$, $p - 1$ is even.
    have evenp_sub_two : Even (p - 2) := by
      have h := Nat.Prime.odd_of_ne_two h