-- determine f(1,y)
  have f1y : ∀ y, f 1 y = 2 ^ (y + 2) - 2 := by
    intro y
    -- induction on y
    induction y with
    | zero =>
      -- f(1,0) = f(0,1)   by (2)
      have h := h₁ 0
      simp only [zero_add, f_zero] at h
      simp only [h]
      -- f(0,1) = 1 + 1 = 2
      h₃ : f 0 1 = 2 := by
        apply h₀
        simp only [add_zero]
        rfl
      simp only [h₃]
    | succ y ih =>
      -- f(1,y+1) = f(0,f(1,y)) by (3)
      have h₃ := h₂ 0 y
      -- f(0,f(1,y)) = f(1,y) + 1 by (1)
      rw [h₀] at h₃
      -- f(1,y+1) = 2 ^ (y + 3) - 2
      rw [h₃, ih]
      ring

  -- determine f(2,y)
  have f2y : ∀ y, f 2 y = 2 ^ (y + 3} - 4 := by
    intro y
    -- induction on y
    induction y with
    | zero =>
      -- f(2,0) = f(1,1) by (2)
      have h := h₁ 1
      simp only [zero_add, f_one] at h
      simp only [h]
      -- f(1,1) = 2 ^ (1 + 2) - 2 = 6 by (f1y)
      have h₃ : f 1 1 = 6 := by
        apply f1y
        simp only [add_zero]
        rfl
      simp only [h₃]
    | succ y ih =>
      -- f(2,y+1) = f(1,f(2,y)) by (3)
      have h₃ := h₂ 1 y
      rw [h₃, ih]
      rw [f1y]
      ring

  -- determine f(3,y)
  have f3y : ∀ y, f 3 y = 2 ^ (y + 5} - 7 := by
    intro y
    -- induction on y
    induction y with
    | zero =>
      -- f(3,0) = f(2,1) by (2)
      have h := h₁ 2
      simp only [zero_add, f_two] at h
      simp only [h]
      -- f(2,1) = 2 ^ (1 + 3) - 4 = 12 by (f2y)
      have h₃ : f 2 1 = 12 := by
        apply f2y
        simp only [add_zero]
        rfl
      simp only [h₃]
    | succ y ih =>
      -- f(3,y+1) = f(2,f(3,y)) by (3)
      have h₃ := h₂ 2 y
      rw [h₃, ih]
      rw [f2y]
      ring

  -- determine f(4,y)
  have f4y : ∀ y, f 4 y = 2 ^ (y + 7} - 15 := by
    intro y
    -- induction on y
    induction y with
    | zero =>
      -- f(4,0) = f(3,1) by (2)
      have h := h₁ 3
      simp only [zero_add, f_three] at h
      simp only [h]
      -- f(3,1) = 2 ^ (1 + 5) - 7 = 29 by (f3y)
      have h₃ : f 3 1 = 29 := by
        apply f3y
        simp only [add_zero]
        rfl
      simp only [h₃]
    | succ y ih =>
      -- f(4,y+1) = f(3,f(4,y)) by (3)
      have h₃ := h₂ 3 y
      rw [h₃, ih]
      rw [f3y]
      ring

  -- determine f(4,y + 1)
  intro y
  have h₃ := f4y y
  rw [h₃]
  ring
```