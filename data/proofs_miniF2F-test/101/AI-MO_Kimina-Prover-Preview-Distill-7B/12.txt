-- determine f(1,y)
  have h₁' (n : ℕ) : f 1 n = n + 2 := by
    -- determine f(1,0)
    have h₁' : f 1 0 = 1 := by
      simp [h₁]
    -- determine f(1,y)
    induction n with
    | zero => simp [h₁']
    | succ n ih =>
      simp [h₂, ih]
      have h : f 1 (n + 1) = f 1 n + 1 := by
        have h : ∀ x, f x (n + 1) = f x n + 1 := by
          intro x
          rw [h₂ x n]
          apply Nat.add_right_cancel
        specialize h 1
        exact h
      rw [h, ih]

  -- determine f(2,y)
  have h₂' (n : ℕ) : f 2 n = 2 ^ (n + 3) - 3 := by
    -- determine f(2,0)
    have h₂' : f 2 0 = 3 := by
      simp [h₁', h₁]
    -- determine f(2,y)
    induction n with
    | zero => simp [h₂']
    | succ n ih =>
      simp [h₂, ih]
      have h : f 2 (n + 1) = 2 * f 2 n - 1 := by
        rw [h₂, h₁', pow_succ]
        ring_nf
      rw [h, ih]

  -- determine f(3,y)
  have h₃' (n : ℕ) : f 3 n = 2 ^ (2 ^ (n + 3) - 3) - 3 := by
    -- determine f(3,0)
    have h₃' : f 3 0 = 5 := by
      simp [h₁', h₁, h₂']
    -- determine f(3,y)
    induction n with
    | zero => simp [h₃']
    | succ n ih =>
      simp [h₂, h₃', ih]
      let h := h₂
      rw [h₃', h, pow_succ]
      ring_nf

  -- determine f(4,y)
  have h₄' (n : ℕ) : f 4 n = 2 ^ (2 ^ (2 ^ (n + 3) - 3) - 3) - 3 := by
    -- determine f(4,0)
    have h₄' : f 4 0 = 13 := by
      simp [h₁', h₁, h₂', h₃']
    -- determine f(4,y)
    induction n with
    | zero => simp [h₄']
    | succ n ih =>
      simp [h₂, h₄', ih]
      let h := h₂
      rw [h₄', h, pow_succ]
      ring_nf

  -- determine f(4,1981)
  simp [h₄']
```