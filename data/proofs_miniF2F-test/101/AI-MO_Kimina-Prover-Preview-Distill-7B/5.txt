--lemma to simplify the expression
  have l_1 (x y : ℕ) : x > 0 → y > 0 → f x y > 0 := by
    intro hx hy
    induction' y using Nat.strong_induction_on with y ih
    cases' y with y
    · simp
      intro hx
      have : f x 0 > 0 := by
        have : f x 0 = f (x - 1) 1 := h₁ (x - 1)
        rw [this]
        have : x - 1 > 0 := by
          exact Nat.sub_pos_of_lt hx
        have := ih (x - 1) this
        exact Nat.succ_pos (f (x - 1) 1)
      exact this
    · rename_i y'
      rw [Nat.add_succ_comm]
      have : y' > 0 := by
        exact Nat.zero_lt_succ y'
      have hx := ih x this
      have h1 := ih (x + 1) (by simp)
      rw [h₂]
      simp
      have : f x (f (x + 1) y') > 0 := by
        have h1 : f x (f (x + 1) y') > 0 := by
          apply Nat.succ_pos
          exact f_pos (x + 1) (y' + 1) (by simp)
        linarith
      apply Nat.succ_pos
      exact f_pos x (y' + 1) (by simp)

  -- (1) $f(0,y)=y+1$
  have r_1 (y : ℕ) : f 0 y = y + 1 := h₀ y

  -- (2) $f(x+1,0)=f(x,1)$
  have r_2 (x : ℕ) : f (x + 1) 0 = f x 1 := h₁ x

  -- (3) $f(x+1,y+1)=f(x,f(x+1,y))$
  have r_3 (x y : ℕ) : f (x + 1) (y + 1) = f x (f (x + 1) y) := h₂ x y

  -- determine $f(4, y)$
  have r_4 (y : ℕ) : f 4 (y + 1) = 2 ^ (f 4 y + 3) - 3 := by
    -- given $f(4, y)$, determine $f(4, y+1)$
    have p_4 (y : ℕ) : f 4 (y + 1) = 2 ^ (f 4 y + 3) - 3 := by
      -- we need the value of $f(4, y)$, we prove by induction in the reverse way
      induction' y using Nat.strong_induction_on with y ih
      cases' y with y
      · simp
        have : f 4 1 = 5 := by
          have : f 4 1 = f 3 2 := by
            rw [r_3 3 0]
            simp
            rw [r_3 2 0]
            simp
            rw [r_3 1 0]
            simp
            rw [r_3 0 0]
            simp
            rw [r_1 0]
            simp
          rw [this]
          simp
          have : f 2 1 > 0 := by
            apply f_pos
            all_goals simp
          have : f 3 2 > 0 := by
            apply f_pos
            all_goals simp
          rw [Nat.sub_succ]
          simp
          linarith
        rw [this]
        simp
      · rename_i y'
        rw [Nat.add_succ_comm]
        have : y' > 0 := by
          exact Nat.zero_lt_succ y'
        have hx := ih y' this
        have h1 := ih (y' + 1) (by simp)
        rw [r_3 4 y']
        simp
        have t1 : f 4 (y' + 1) > 0 := by
          apply f_pos
          all_goals simp
        have t2 : f 4 (y' + 1) + 3 > 0 := by
          linarith
        rw [Nat.sub_succ]
        simp
        have t3 : 2 ^ (f 4 (y' + 1) + 3) - 3 > 0 := by
          have : 2 ^ (f 4 (y' + 1) + 3) > 0 := by
            apply Nat.pow_pos
            norm_num
          linarith
        have t4 : 2 ^ (f 4 (y' + 1) + 3) - 3 > f 4 (y' + 1) + 3 := by
          have : 2 ^ (f 4 (y' + 1) + 3) > 2 ^ 0 := by
            have : f 4 (y' + 1) + 3 > 0 := by
              linarith
            exact Nat.pow_lt_pow_of_lt (by norm_num) this
          linarith
        have : 2 ^ (f 4 (y' + 1) + 3) - 3 > f 4 (y' + 1) := by
          linarith
        linarith
    have : f 4 (y + 1) = 2 ^ (f 4 y + 3) - 3 := by
      apply p_4 (y + 1)
    rw [this]
  exact r_4

```