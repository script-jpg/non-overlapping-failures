have step : a 1 + b 1 = 1 / 2 ^ 98 := by
    have h₄ : ∀ n, a n = a 1 * (Real.sqrt 3) ^ n / 2 ^ n + b 1 * (-1 : ℝ) ^ n / 2 ^ n := by
      intro n
      induction n with
      | zero =>
        norm_num [pow_zero, pow_one]
        <;> ring_nf at * <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num)]
      | succ n ih =>
        simp_all [pow_succ, h₀, h₁, mul_add, mul_sub, mul_comm, mul_left_comm, mul_assoc,
          div_eq_mul_inv]
        <;> ring_nf at * <;> field_simp at * <;>
        nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num),
          Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num)]
    have h₅ := h₄ 100
    have h₆ := h₄ 99
    have h₇ := h₄ 0
    have h₈ := h₄ 1
    have h₉ := h₄ 2
    have h₁₀ := h₄ 3
    simp at h₅ h₆ h₇ h₈ h₉
    norm_num [pow_succ, pow_zero, pow_one, mul_assoc] at *
    ring_nf at *
    <;> field_simp [pow_succ, pow_zero, pow_one] at *
    <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num),
      Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num),
      Real.sq_sqrt (show 0 ≤ (3 : ℝ) by norm_num),
      Real.sqrt_pos_of_pos (show (0 : ℝ) < 3 by norm_num)]
  exact step