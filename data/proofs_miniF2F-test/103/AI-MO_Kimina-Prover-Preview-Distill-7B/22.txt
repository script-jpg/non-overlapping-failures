-- `x * 9 % 100 = 1` is equivalent to `x * 9 = 1 + 100 * n` for some integer $n$.
  have h₂ (n : ℤ) : x * 9 = 1 + 100 * n ↔ x * 9 % 100 = 1 := by
    constructor
    · intro h
      rw [Int.natCast_add, Int.natCast_mul]
      refine Int.natCast_inj.mp?_
      refine (Int.modEq_iff_dvd'?_).mpr?_
      have : (1 + 100 * n) % 100 = 1 := by
        rw [Int.add_emod, Int.mul_emod]
        simp only [Int.reduceMul, Int.reduceAdd, Int.reduceMod, Nat.cast_one, mul_one]
      refine this.mpr?_
      exact Int.dvd_sub (by rfl) h
    · intro h
      by_cases h' : n ≥ 0
      · exact Int.natCast_inj.mp (id (Eq.symm h))
      · have : n = 0 ∨ n = -1 ∨ n ≤ -2 := by omega
        rcases this with (h' | h' | h') <;> simp only [h', add_zero, one_mul, Nat.cast_neg, Int.reduceNeg] at h ⊢ <;> refine Int.natCast_inj.mp?_; simp [Int.modEq_iff_dvd', Int.add_emod, Int.mul_emod] at h ⊢ <;> exact (Int.dvd_sub (by rfl) h).symm

  -- From `x * 9 = 1 + 100 * n` we can get `x = 89` or `x = 69` or `x = 49` or `x = 29`.
  have h₃ (n : ℤ) : x * 9 = 1 + 100 * n → x = 89 ∨ x = 69 ∨ x = 49 ∨ x = 29 := by
    intro h
    have h₄ : x ≤ 99 := by exact Nat.le_of_lt_succ h₀
    have h₅ : x ≥ 0 := by exact Nat.zero_le x
    have h₆ : x = 89 ∨ x = 69 ∨ x = 49 ∨ x = 29 := by
      generalize h₇ : x = n at h
      revert h
      revert n
      native_decide
    exact h₆

  -- `x` is one of 89, 69, 49, 29. We eliminate the other four cases by `omega`.
  rcases h₃ (n : ℤ) h₂ (n : ℤ) with (h | h | h | h) <;> simp only [h] at h₁ <;> omega

```