have step₁ : ∀ n, 0 < n → f n = n := by
    have h₂ : ∀ n, 0 < n → f n = n := by
      intro n hn
      induction n using Nat.strong_induction_on with
      | h n ih =>
        cases n with
        | zero => contradiction
        | succ n =>
          have h₃ := h₁ (n + 1) (by linarith)
          have h₄ := ih (f (n + 1)) (by
            have h₅ : f (n + 1) > 0 := h₀ (n + 1)
            linarith)
          have h₆ := h₁ (f (n + 1))
          have h₇ : f (f (n + 1)) < f (n + 1 + 1) := h₁ (n + 1) (by linarith)
          have h₈ : f (n + 1) > 0 := h₀ (n + 1)
          have h₉ : f (f (n + 1)) < f (n + 1 + 1) := h₁ (n + 1) (by linarith)
          have h₁₀ : f (n + 1) ≥ n + 1 := by
            by_contra h
            have h₁₁ : f (n + 1) ≤ n := by linarith
            have h₁₂ : f (n + 1) < n + 1 := by linarith
            nlinarith [h₀ (n + 1), h₀ (f (n + 1)), h₁ (n + 1) (by linarith)]
          have h₁₁ : f (n + 1) = n + 1 := by
            have h₁₃ : f (n + 1) ≥ n + 1 := h₁₀
            have h₁₄ : f (n + 1) ≤ n + 1 := by
              by_contra h₁₅
              have h₁₆ : f (n + 1) > n + 1 := by omega
              have h₁₇ : f (f (n + 1)) < f (n + 1 + 1) := h₁ (n + 1) (by linarith)
              have h₁₈ : f (f (n + 1)) ≥ f (n + 1) := by
                apply?
              nlinarith [h₀ (n + 1), h₀ (f (n + 1)), h₁ (n + 1) (by linarith)]
            omega
          simp_all
          <;> omega
    intro n hn
    exact h₂ n hn
  
  have step₂ : ∀ n, 0 < n → f n = n := by
    exact step₁
  
  exact step₂
```