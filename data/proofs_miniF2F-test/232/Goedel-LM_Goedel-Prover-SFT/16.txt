have h₂ : a = 663 / 266 := by
    have h₃ : 0 < a.den := Nat.succ_pos a.den
    have h₄ : 0 < a.num := a.num_pos
    have h₅ : a * 1 + a.den = 1000 * a.num := by
      -- Porting note: has to do this to get m = 1000a.num
      -- convert_to (a + a.den) = 1000 * a.num
      -- change (a + a.den : ℚ) = _
      dsimp [div_eq_mul_inv] at h₀ ⊢
      rw [← cast_add, mul_comm] at h₀
      norm_cast at h₀ ⊢
      rw [← Rat.div_eq_iff h₃ h₄, div_eq_iff_mul_eq h₃ h₄, add_comm, ← Rat.div_eq_iff h₃ h₄] at h₀
      rw [h₀, mul_comm 1000, mul_comm 1000]
    have h₆ : 2 * 1000 * a.num = 663 * 1000 * a.den := by
      rw [h₅, mul_right_comm, ← mul_assoc]
    have h₇ : 2 * a.num = 663 * a.den := by
      apply_fun 1000 at h₆
      simpa only [mul_assoc, mul_right_comm] using h₆
    have h₈ : a.num = 663 * a.den / 2 := by linarith
    rw [h₈]
    field_simp
    norm_cast
    norm_num
    rfl
  rw [h₂]
  norm_num
```