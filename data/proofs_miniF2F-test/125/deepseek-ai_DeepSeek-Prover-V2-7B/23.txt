have step₁ : a = 1 := by
    have h₆ := h₂.1
    have h₇ := h₂.2.1
    have h₈ := h₂.2.2
    have h₉ := h₁.1
    have h₁₀ := h₁.2.1
    have h₁₁ := h₁.2.2.1
    have h₁₂ := h₁.2.2.2
    have h₁₃ : a * d = b * c := h₃
    have h₁₄ : a + d = 2 ^ k := h₄
    have h₁₅ : b + c = 2 ^ m := h₅
    have h₁₆ := h₁₀
    have h₁₇ := h₁₁
    have h₁₈ := h₁₂
    have h₁₉ := h₉
    have h₂₀ := h₆
    have h₂₁ := h₇
    have h₂₂ := h₈
    have h₂₃ : a > 0 := by linarith
    have h₂₄ : b > 0 := by linarith
    have h₂₅ : c > 0 := by linarith
    have h₂₆ : d > 0 := by linarith
    have h₂₇ : a ≤ 2 ^ k := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) k]
    have h₂₈ : b ≤ 2 ^ m := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) m]
    have h₂₉ : a < b := by linarith
    have h₃₀ : b < c := by linarith
    have h₃₁ : c < d := by linarith
    have h₃₂ : d ≤ 2 ^ k := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) k]
    have h₃₃ : a ≤ 2 ^ k := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) k]
    have h₃₄ : b ≤ 2 ^ m := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) m]
    have h₃₅ : c ≤ 2 ^ m := by
      nlinarith [pow_pos (by norm_num : (0 : ℕ) < 2) m]
    -- Use the bounds to show that a must be 1
    have h₃₆ : a = 1 := by
      -- Use the fact that a is odd and less than b, which is less than c, and so on
      cases' k with k
      · simp_all [pow_zero]
        <;> omega
      · cases' m with m
        · simp_all [pow_zero]
          <;> omega
        · simp_all [pow_succ]
          <;>
            (try omega) <;>
            (try {
              have : a ≤ 3 := by
                nlinarith
              interval_cases a <;> simp_all (config := {decide := true}) <;> omega
            }) <;>
            (try {
              have : b ≤ 3 := by
                nlinarith
              have : c ≤ 3 := by
                nlinarith
              have : d ≤ 3 := by
                nlinarith
              interval_cases b <;> interval_cases c <;> interval_cases d <;> simp_all (config := {decide := true}) <;> omega
            })
            <;>
            (try {
              ring_nf at *
              omega
            })
            <;>
            omega
    exact h₃₆
  
  exact step₁
```