have step₁ : a = 1 := by
    have h₆ := h₁.1
    have h₇ := h₁.2.1
    have h₈ := h₁.2.2.1
    have h₉ := h₁.2.2.2
    have h₁₀ := h₂.1
    have h₁₁ := h₂.2.1
    have h₁₂ := h₂.2.2
    have h₁₃ : a * d = b * c := h₃
    have h₁₄ : a + d = 2 ^ k := h₄
    have h₁₅ : b + c = 2 ^ m := h₅
    have h₁₆ : a ≤ 2 ^ k := by
      nlinarith [Nat.one_le_pow k 2 (by norm_num)]
    have h₁₇ : b ≤ 2 ^ m := by
      nlinarith [Nat.one_le_pow m 2 (by norm_num)]
    have h₁₈ : d ≤ 2 ^ k := by
      nlinarith [Nat.one_le_pow k 2 (by norm_num)]
    have h₁₉ : c ≤ 2 ^ m := by
      nlinarith [Nat.one_le_pow m 2 (by norm_num)]
    have h₂₀ : a ≤ 2 ^ k := by
      nlinarith [Nat.one_le_pow k 2 (by norm_num)]
    have h₂₁ : b ≤ 2 ^ m := by
      nlinarith [Nat.one_le_pow m 2 (by norm_num)]
    have h₂₂ : d ≤ 2 ^ k := by
      nlinarith [Nat.one_le_pow k 2 (by norm_num)]
    have h₂₃ : c ≤ 2 ^ m := by
      nlinarith [Nat.one_le_pow m 2 (by norm_num)]
    -- We will show that a = 1 by eliminating other possibilities.
    have h₂₄ : a = 1 := by
      -- Since a is odd and a < b, a can only be 1.
      cases' k with k
      · simp_all [pow_zero]
        <;> omega
      · cases' m with m
        · simp_all [pow_zero]
          <;> omega
        · simp_all [Nat.pow_succ, Nat.mul_assoc]
          <;>
          (try omega) <;>
          (try
            {
              have h₂₅ : a = 1 := by
                ring_nf at *
                have h₂₆ : a ≤ 3 := by
                  nlinarith
                interval_cases a <;> simp_all (config := {decide := true}) <;>
                  (try omega) <;>
                  (try omega) <;>
                  (try omega)
              simp_all
            }) <;>
          (try omega) <;>
          (try omega)
    exact h₂₄
  
  exact step₁
```