-- Need to import Mathlib and Aesop to use mathematical libraries and automated tactics.
  import Mathlib
  import Aesop

  set_option maxHeartbeats 0

  open BigOperators Real Nat Topology Rat

  -- The theorem states that the product of all positive odd integers less than 10000 equals 10000! divided by (2^5000 * 5000!).
  theorem amc12_2001_p5 :
      Finset.prod (Finset.filter (fun x => ¬Even x) (Finset.range 10000)) (id : ℕ → ℕ) =
        10000! / (2 ^ 5000 * 5000!) := by

    -- The key insight is to express the product of odd numbers using a factorial representation.
    -- We can write the product as:
    -- 1 × 3 × 5 × 7 ×... × 9999 = (1 × 2 × 3 × 4 × 5 × 6 × 7 × 8 ×... × 10000) / (2 × 4 × 6 ×... × 10000)
    -- This is because the product of odd numbers is the product of all numbers divided by the product of even numbers.
    -- The product of the first n even numbers is 2^n × n!.

    -- Therefore, the product of all positive odd integers less than 10000 equals:
    -- 10000! / (2^5000 × 5000!)
    -- This matches answer choice (D).

    -- Start the proof by creating a bijection between the set of odd numbers and a set of pairs.
    let φ : ℕ × ℕ → ℕ × ℕ := fun ⟨n, m⟩ => ⟨n * m, n * m + 1⟩

    -- Prove φ is injective when mapping from the set of odd numbers to a set of pairs.
    have inj_φ : Set.InjOn φ (Set.range 5000 ×ˢ Set.range 2) := by
      intro ⟨n, b⟩ ⟨n', b'⟩ h
      simp at h
      linarith

    -- Establish that the range of φ is the set of odd numbers.
    have range_φ : φ '' (Set.range 5000 ×ˢ Set.range 2) = (Finset.filter (fun x => ¬Even x) (Finset.range 10000)) := by
      ext x
      simp
      constructor
      · rintro ⟨n, b, h⟩
        rcases b with ⟨b₁, b₂⟩
        subst h
        subst b
        omega
      · rintro ⟨h1, h2⟩
        use x / 2, 0.get h1
        omega

    -- Calculate the product of the odd numbers using the properties of φ.
    calc
      Finset.prod (Finset.filter (fun x => ¬Even x) (Finset.range 10000)) (id : ℕ → ℕ)
        = Finset.prod (φ '' (Set.range 5000 ×ˢ Set.range 2)) (id : ℕ → ℕ) := by rw [range_φ]
      _ = Finset.prod (Set.range 5000 ×ˢ Set.range 2) (fun ⟨n, m⟩ => n * m) := by
        -- The product of the image of φ equals the product of the domain.
        rw [Finset.prod_image]
        simp [Set.InjOn.map_comp]
        exact inj_φ
      _ = (Finset.prod (Set.range 5000) (fun n => n)) * (Finset.prod (Set.range 2) (fun m => m)) := by
        -- The product of the Cartesian product equals the product of the factors.
        rw [Finset.prod_product]
      _ = 5000! * 1 := by
        -- The product of numbers from 0 to n-1 equals (n-1)!.
        simp
      _ = 10000! / (2 ^ 5000 * 5000!) := by
        -- Show that 5000! * 1 equals 10000! / (2^5000 * 5000!).
        have h : 10000! = 2 ^ 5000 * 5000! * 5000! := by
          -- Use properties of factorials and powers of 2.
          calc 10000!
              = 10000 * 9999 * 9998 * 9997 * 9996 * 9995 * 9994 * 9993 * 9992 * 9991 * 9990 * 9989 * 9988 * 9987 * 9986 * 9985 * 9984 * 9983 * 9982 * 9981 * 9980 * 9979 * 9978 * 9977 * 9976 * 9975 * 9974 * 9973 * 9972 * 9971 * 9970 * 9969 * 9968 * 9967 * 9966 * 9965 * 9964 * 9963 * 9962 * 9961 * 9960 * 9959 * 9958 * 9957 * 9956 * 9955 * 9954 * 9953 * 9952 * 9951 * 9950 * 9949 * 9948 * 9947 * 9946 * 9945 * 9944 * 9943 * 9942 * 9941 * 9940 * 9939 * 9938 * 9937 * 9936 * 9935 * 9934 * 9933 * 9932 * 9931 * 9930 * 9929 * 9928 * 9927 * 9926 * 9925 * 9924 * 9923 * 9922 * 9921 * 9920 * 9919 * 9918 * 9917 * 9916 * 9915 * 9914 * 9913 * 9912 * 9911 * 9910 * 9909 * 9908 * 9907 * 9906 * 9905 * 9904 * 9903 * 9902 * 9901 * 9900 * 9899 * 9898 * 9897 * 9896 * 9895 * 9894 * 9893 * 9892 * 9891 * 9890 * 9889 * 9888 * 9887 * 9886 * 9885 * 9884 * 9883 * 9882 * 9881 * 9880 * 9879 * 9878 * 9877 * 9876 * 9875 * 9874 * 9873 * 9872 * 9871 * 9870 * 9869 * 9868 * 9867 * 9866 * 9865 * 9864 * 9863 * 9862 * 9861 * 9860 * 9859 * 9858 * 9857 * 9856 * 9855 * 9854 * 9853 * 9852 * 9851 * 9850 * 9849 * 9848 * 9847 * 9846 * 9845 * 9844 * 9843 * 9842 * 9841 * 9840 * 9839 * 9838 * 9837 * 9836 * 9835 * 9834 * 9833 * 9832 * 9831 * 9830 * 9829 * 9828 * 9827 * 9826 * 9825 * 9824 * 9823 * 9822 * 9821 * 9820 * 9819 * 9818 * 9817 * 9816 * 9815 * 9814 * 9813 * 9812 * 9811 * 9810 * 9809 * 9808 * 9807 * 9806 * 9805 * 9804 * 9803 * 9802 * 9801 * 9800 * 9799 := by
              rw [Nat.factorial]
              native_decide
          _ = (2 ^ 5000 * 5000!) * 5000! := by
              rw [Nat.factorial]
              rw [← Nat.mul_factorial_pred 5000]
              rw [Nat.mul_factorial_pred 5000]
              rw [← Nat.pow_add_one 2 5000]
              rw [Nat.mul_factorial_pred 5000]
              native_decide
        -- Use the above property to show the desired result.
        rw [h]
        simp

```