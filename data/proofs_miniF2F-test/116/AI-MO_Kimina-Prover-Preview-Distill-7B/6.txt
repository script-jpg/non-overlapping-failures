have h₁ : ((n + 2)! - (n + 1)!) / n! = ((n + 2) * (n + 1) - (n + 1)) * (1 / n!) := by

    calc

      ((n + 2)! - (n + 1)!) / n! = ((n + 2) * (n + 1) * n! - (n + 1) * n!) / (n!) := by rw [Nat.factorial_succ, Nat.factorial_succ]

      _ = ((n + 2) * (n + 1) - (n + 1)) * (n! / n!) := by ring_nf; rw [Nat.mul_assoc, Nat.mul_sub, Nat.mul_one, Nat.mul_assoc, Nat.mul_one]

      _ = ((n + 2) * (n + 1) - (n + 1)) * (1 / n!) := by rw [Nat.div_self]; symm; apply Nat.ne_of_gt; apply Nat.factorial_pos

  rw [h₁]

  have h₂ : ((n + 2) * (n + 1) - (n + 1)) = (n + 1) * n := by

    ring_nf

    rw [Nat.mul_assoc, Nat.mul_sub, Nat.mul_one, Nat.mul_assoc, Nat.mul_one]; ring_nf

  rw [h₂]

  rcases Nat.exists_eq_add_of_le h₀ with ⟨k, hk⟩

  have h₃ : (k + 10) * (k + 9) * ((k + 9)! / ((k + 9)!) : ℝ) = (k + 10) * (k + 9) * (1 : ℝ) := by

    norm_cast

    have : (k + 9)! = (k + 9) * (k + 8) * (k + 7) * (k + 6) * (k + 5) * (k + 4) * (k + 3) * (k + 2) * (k + 1) * (k + 0)! := by rw [Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ]; ring_nf

    rw [this, Nat.factorial_zero, Nat.mul_zero, Nat.mul_one, Nat.mul_zero]; simp

  rcases Nat.factorial_zero le_rfl with h₄

  set x := (k + 10) * (k + 9)

  use x

  rw [h₃, h₄]

  norm_cast

  ring_nf

  rw [Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ, Nat.factorial_succ]; ring_nf

  rw [hk]

  ring_nf

  <;> try linarith
```