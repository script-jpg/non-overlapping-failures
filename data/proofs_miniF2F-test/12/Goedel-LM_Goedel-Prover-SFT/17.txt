have h₁ : 3 + x ∈ ({1, 3, 4, 53, 144} : Set ℝ) :=
    (Set.mem_insert_iff.2 (Or.inl rfl)).2 fun h =>
      Set.not_mem_singleton_iff.2 fun h' =>
        Set.not_mem_singleton_iff.2
          fun h'' : 3 + x = 53 => by
            have h''' : x = 50 := by linarith
            rw [h''', h''''] at h₀; norm_num at h₀
          ((Set.mem_singleton_iff.1 (h.resolve_left (Ne.symm (by norm_num : (1 : ℝ) ≠ 3)))).resolve_left
            (Ne.symm (by norm_num : (3 : ℝ) ≠ 4))).resolve_left ((Set.mem_singleton_iff.1 h).resolve_right
          (Ne.symm (by norm_num : (4 : ℝ) ≠ 144)))
          (by linarith)
  have : 3 + x = 1 ∨ 3 + x = 53 ∨ 3 + x = 144 := by
    simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at h₁
    rcases h₁ with (h₁ | h₁ | h₁ | h₁) <;>
    simp only [h₁, ← sub_eq_iff_eq_add', add_sub_cancel, eq_self_iff_true, not_true, false_or_iff,
      add_eq_zero_iff, sub_eq_iff_eq_add, not_false_iff, add_right_inj, mul_one, or_true_iff]
  rcases this with (h₁ | h₁ | h₁) <;>
  (try
  {
    -- Porting note:
    -- `norm_num at h₀` is not necessary here.
    apply Eq.symm
    rw [← mul_right_inj' (show ((3 : ℝ) : ℝ) ≠ 0 by norm_num)] at h₀
    linarith
  }) <;>
  (try
  {
    -- Porting note:
    -- `norm_num at h₀` is not necessary here.
    apply Eq.symm
    rw [← mul_right_inj' (show ((3 : ℝ) : ℝ) ≠ 0 by norm_num)] at h₀
    linarith
  })
```