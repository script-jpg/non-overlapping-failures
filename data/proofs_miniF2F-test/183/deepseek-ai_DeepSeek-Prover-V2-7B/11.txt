have h₂ : f ⁻¹' {0} = {20} := by
    ext x
    simp only [h₀, Set.mem_preimage, Set.mem_singleton_iff, Set.mem_setOf_eq]
    constructor
    · intro h
      have h₃ : x ^ 2 + (18 * x + 30) - 2 * Real.sqrt (x ^ 2 + (18 * x + 45)) = 0 := h
      have h₄ : 0 ≤ Real.sqrt (x ^ 2 + (18 * x + 45)) := Real.sqrt_nonneg (x ^ 2 + (18 * x + 45))
      have h₅ : Real.sqrt (x ^ 2 + (18 * x + 45)) ≥ 0 := Real.sqrt_nonneg (x ^ 2 + (18 * x + 45))
      have h₆ : (Real.sqrt (x ^ 2 + (18 * x + 45))) ^ 2 = x ^ 2 + (18 * x + 45) := Real.sq_sqrt (by nlinarith)
      nlinarith [sq_nonneg (x - 20), sq_nonneg (x + 20), sq_nonneg (Real.sqrt (x ^ 2 + (18 * x + 45)) - 45),
        Real.sqrt_nonneg (x ^ 2 + (18 * x + 45)), Real.sq_sqrt (by nlinarith : (0 : ℝ) ≤ x ^ 2 + (18 * x + 45))]
    · intro h
      rw [h]
      have h₃ : Real.sqrt (20 ^ 2 + (18 * 20 + 45)) = 45 := by
        rw [Real.sqrt_eq_iff_sq_eq] <;> norm_num
        <;> nlinarith
      nlinarith [Real.sqrt_nonneg (20 ^ 2 + (18 * 20 + 45)), h₃]
  
  have h₃ : (f ⁻¹' {0}).toFinset = {20} := by
    rw [h₂]
    <;> simp [Set.toFinset_singleton]
    <;> infer_instance
  
  have h₄ : ∏ x in (f ⁻¹' {0}).toFinset, x = 20 := by
    rw [h₃]
    simp [Finset.prod_singleton]
    <;> norm_num
  
  simp_all
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
```