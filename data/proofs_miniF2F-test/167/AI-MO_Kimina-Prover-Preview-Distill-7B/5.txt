-- lemma about sequence
  -- if exist a sub sequence which every term > 1 or every term < 0,
  -- then the limit of the sub sequence is not 0.
  have lemma_subsequence {s : ℕ → ℝ} (m : NNReal) (h : ∀ n, s n > 1) : Filter.Tendsto s atTop BddBelow₀ := by
    by_contra! h₀
    let a := s 0
    have ha : ∀ n, s n > a := by
      intro n
      induction n with
      | zero => simp [a]
      | succ n ih =>
        rw [lt_add_iff_pos_left] at h n
        exact h n
    let f : ℕ → ℝ := fun n => s (n + m)
    have hf : ∀ n, f (n + 1) = f n + 1 := by
      intro n
      simp [f]
      rw [h n]
    have h₂ : ∀ n, f n > 0 := by
      intro n
      induction n with
      | zero => simp [a]; exact h 0
      | succ n ih =>
        rw [hf n]
        linarith [ih]
    have h₃ : Filter.Tendsto f atTop BddBelow₀ := by
      have : Filter.Tendsto (fun n => s (n + m)) atTop (Set.Ioi 0) := by
        simp_rw [Set.mem_Ioi]
        rw [<-h₂]
        exact h₀
      apply Filter.Tendsto.mono (Prod.mk_left_inj (a := 0) (by simp)) this
    have h₄ : ¬ Filter.Tendsto f atTop BddBelow₀ := by
      simp_rw [Set.mem_Iio]
      rw [<-tendsto_atTop_iff_tendsto_nhds_atTop]
      have h₄ : f + (1 : ℕ → ℝ) = fun n => s (n + m + 1) := by
        ext n
        rw [hf]
      rw [h₄]
      exact tendsto_nhds_atTop_of_not_exists_nhds atTop
    exact h₃ h₄

  have lemma_subsequence' {s : ℕ → ℝ} (m : NNReal) (h : ∀ n, s n < 0) : Filter.Tendsto s atTop BddAbove₀ := by
    by_contra! h₀
    let a := s 0
    have ha : ∀ n, s n < a := by
      intro n
      induction n with
      | zero => simp [a]
      | succ n ih =>
        rw [lt_add_iff_neg_left] at h n
        exact h n
    let f : ℕ → ℝ := fun n => s (n + m)
    have hf : ∀ n, f (n + 1) = f n + 1 := by
      intro n
      simp [f]
      rw [h n]
    have h₂ : ∀ n, f n < 0 := by
      intro n
      induction n with
      | zero => simp [a]; exact h 0
      | succ n ih =>
        rw [hf n]
        linarith [ih]
    have h₃ : Filter.Tendsto f atTop BddAbove₀ := by
      have : Filter.Tendsto (fun n => s (n + m)) atTop (Set.Iio 0) := by
        simp_rw [Set.mem_Iio]
        rw [<-h₂]
        exact h₀
      apply Filter.Tendsto.mono (Prod.mk_right_inj (a := 0) (by simp)) this
    have h₄ : ¬ Filter.Tendsto f atTop BddAbove₀ := by
      simp_rw [Set.mem_Ioi]
      rw [<-tendsto_atTop_iff_tendsto_nhds_atTop]
      have h₄ : f + (1 : ℕ → ℝ) = fun n => s (n + m + 1) := by
        ext n
        rw [hf]
      rw [h₄]
      exact tendsto_nhds_atTop_of_not_exists_nhds atTop
    exact h₃ h₄

  -- if exist a sub sequence which every term > 1 or every term < 0,
  -- then the limit of the sub sequence is not 0.
  have lemma_subsequence {s : ℕ → ℝ} (m : NNReal) (h : ∀ n, s n > 1) : Filter.Tendsto s atTop BddBelow₀ := by
    by_contra! h₀
    let a := s 0
    have ha : ∀ n, s n > a := by
      intro n
      induction n with
      | zero => simp [a]
      | succ n ih =>
        rw [lt_add_iff_pos_left] at h n
        exact h n
    let f : ℕ → ℝ := fun n => s (n + m)
    have hf : ∀ n, f (n + 1) = f n * (f n + 1 / n) := by
      intro n
      simp [f]
      rw [h n]
    have h₂ : ∀ n, f n > 0 := by
      intro n
      induction n with
      | zero => simp [a]; exact h 0
      | succ n ih =>
        rw [hf n]
        positivity
    have h₃ : Filter.Tendsto f atTop BddBelow₀ := by
      have : Filter.Tendsto (fun n => s (n + m)) atTop (Set.Ioi 0) := by
        simp_rw [Set.mem_Ioi]
        rw [<-h₂]
        exact h₀
      apply Filter.Tendsto.mono (Prod.mk_left_inj (a := 0) (by simp)) this
    have h₄ : ¬ Filter.Tendsto f atTop BddBelow₀ := by
      simp_rw [Set.mem_Iio]
      rw [<-tendsto_atTop_iff_tendsto_nhds_atTop]
      have h₄ : f * (1 / n + f) = fun n => s (n + m + 1) := by
        ext n
        rw [hf]
      rw [h₄]
      exact tendsto_nhds_atTop_of_not_exists_nhds atTop
    exact h₃ h₄

  have lemma_subsequence' {s : ℕ → ℝ} (m : NNReal) (h : ∀ n, s n < 0) : Filter.Tendsto s atTop BddAbove₀ := by
    by_contra! h₀
    let a := s 0
    have ha : ∀ n, s n < a := by
      intro n
      induction n with
      | zero => simp [a]
      | succ n ih =>
        rw [lt_add_iff_neg_left] at h n
        exact h n
    let f : ℕ → ℝ := fun n => s (n + m)
    have hf : ∀ n, f (n + 1) = f n * (f n + 1 / n) := by
      intro n
      simp [f]
      rw [h n]
    have h₂ : ∀ n, f n < 0 := by
      intro n
      induction n with
      | zero => simp [a]; exact h 0
      | succ n ih =>
        rw [hf n]
        apply mul_neg_of_neg_of_pos
        <;> linarith [ih]
    have h₃ : Filter.Tendsto f atTop BddAbove₀ := by
      have : Filter.Tendsto (fun n => s (n + m)) atTop (Set.Iio 0) := by
        simp_rw [Set.mem_Iio]
        rw [<-h₂]
        exact h₀
      apply Filter.Tendsto.mono (Prod.mk_right_inj (a := 0) (by simp)) this
    have h₄ : ¬ Filter.Tendsto f atTop BddAbove₀ := by
      simp_rw [Set.mem_Ioi]
      rw [<-tendsto_atTop_iff_tendsto_nhds_atTop]
      have h₄ : f * (1 / n + f) = fun n => s (n + m + 1) := by
        ext n
        rw [hf]
      rw [h₄]
      exact tendsto_nhds_atTop_of_not_exists_nhds atTop
    exact h₃ h₄

  -- prove that the'limit'of the sequence is 0
  have x_succ_lt limit : ∀ n, 0 < f n limit ∧ f n limit < f (n + 1) limit ∧ f (n + 1) limit < 1 := by
    intro n
    induction n with
    | zero =>
      specialize h₀ limit
      constructor
     . exact h₀
     . constructor
       . specialize h₁ limit 1
          simp [h₀] at h₁
          exact h₁
       . specialize h₁ limit 1
          simp [h₀] at h₁
          linarith
    | succ n ih =>
      specialize h₁ limit (n + 1)
      specialize ih (le_succ_self _)
      constructor
     . exact ih.left
     . constructor
       . have : f (n + 1) limit < f (n + 1 + 1) limit := by
            specialize h₁ limit (n + 1)
            simp [h₁]
            linarith
          rw [<-add_assoc] at this
          exact this
       . have : 0 < f (n + 1) limit := by
            specialize h₁ limit (n + 1)
            simp [h₁]
            linarith
          have : f (n + 1) limit < 1 := by
            specialize h₁ limit (n + 1)
            simp [h₁]
            linarith
          linarith

  -- By monotonicity, if the sequence $x_1,x_2,\ldots$ is such that $0 < x_n < x_{n+1} < 1$ for every $n$,
  -- then $x_{n+1} = x_n(x_n + \frac{1}{n}) > x_n \cdot 1 = x_n$ so $x_n < x_{n+1}$
  -- Also, $x_{n+1} = x_n(x_n + \frac{1}{n}) < x_n \cdot 1 + \frac{x_n}{n} = x_n + \frac{x_n}{n} < x_n + 1$.
  have x_succ_lt' {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1) < 1) : ∀ n, x n < x (n + 1) ∧ x (n + 1) < x n + 1 := by
    intro n
    specialize h n
    constructor
   . linarith
   . specialize h₁ n x
      simp [h] at h₁
      linarith

  -- If the sequence $x_1,x_2,\ldots$ is such that $0 < x_n < x_{n+1} < 1$ for every $n$,
  -- then $x_{n+1} = x_n(x_n + \frac{1}{n}) < x_n \cdot 1 + \frac{x_n}{n} = x_n + \frac{x_n}{n}$
  have x_succ_lt'' {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1) < 1) : ∀ n, x (n + 1) < x n + x n / (n + 1) := by
    intro n
    specialize h₁ n (x n)
    specialize h n
    have : x n > 0 := h.left
    have : x (n + 1) < x n + x n / n := by
      calc
        _ = x n * (x n + 1 / n) := by rw [h₁]
        _ = x n^2 + x n / n := by field_simp; ring
        _ < x n + x n / n := by
          refine lt_add_of_pos_left?_ (show 0 < x n by linarith)
          calc
            _ < x n * 1 := by norm_num
            _ = x n := by simp
    linarith

  -- it's impossible for a sequence to satisfy $x_{n+1} < x_n + \frac{x_n}{n}$ for every $n$ and still be bounded.
  -- in fact, this sequence must grow without bound.
  have x_not_bdd {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1) < 1) : ¬ BddAbove x := by
    have h₂ : ∀ n, x n < x (n + 1) ∧ x (n + 1) < x n + 1 / n := by
      intro n
      specialize x_succ_lt'' h n
      constructor
     . exact x_succ_lt' h n
     . specialize x_succ_lt'' h n
        linarith
    by_contra! h₃
    have h₄ : ∀ n, x n < x (n + 1) := by
      intro n
      exact (h₂ n).left
    have h₅ : ∀ n, x n < x (n + 1) + 1 / (n + 1) := by
      intro n
      exact (h₂ n).right
    have h₆ : Filter.Tendsto x atTop BddAbove := by
      exact tendsto_atTop_iff_bddAbove.mpr h₃
    have h₇ : ¬ Filter.Tendsto x atTop BddAbove := by
      apply lemma_subsequence
      specialize h₂ 1
      simp at h₂
      rw [<-max_eq_left_iff] at h₂
      simp [max_eq_left_iff] at h₂
      specialize h₂ 2
      simp at h₂
      linarith
    exact h₇ h₆

  -- Hence, if the sequence $x_1,x_2,\ldots$ is such that $0 < x_n < x_{n+1} < 1$ for every $n$,
  -- then the sequence is unbounded.
  have x_not_bdd' {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1) < 1) : ¬ BddBelow x := by
    have h₂ : ∀ n, x n < x (n + 1) ∧ x (n + 1) < x n + 1 / n := by
      intro n
      specialize x_succ_lt'' h n
      constructor
     . exact x_succ_lt' h n
     . specialize x_succ_lt'' h n
        linarith
    by_contra! h₃
    have h₄ : ∀ n, x n < x (n + 1) := by
      intro n
      exact (h₂ n).left
    have h₅ : ∀ n, x n + 1 / n < x (n + 1) := by
      intro n
      specialize (h₂ n).right
      linarith
    have h₆ : Filter.Tendsto x atTop BddBelow := by
      exact tendsto_atTop_iff_bddBelow.mpr h₃
    have h₇ : ¬ Filter.Tendsto x atTop BddBelow := by
      apply lemma_subsequence'
      specialize h₂ 1
      simp at h₂
      rw [<-min_eq_right_iff] at h₂
      simp [min_eq_right_iff] at h₂
      specialize h₂ 2
      simp at h₂
      linarith
    exact h₇ h₆

  -- However, if the sequence $x_1,x_2,\ldots$ is such that $0 < x_n < x_{n+1} < 1$ for every $n$ and $x_1 \leq 1$,
  -- then the sequence is bounded.
  have x_bdd {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1) < 1) : BddAbove x ∧ BddBelow x := by
    have h₁ : ∀ n, 0 < x n := by
      intro n
      specialize h n
      exact h.left
    have h₂ : ∀ n, x n < x (n + 1) := by
      intro n
      exact (h n).left
    have h₃ : ∀ n, x (n + 1) < x n + 1 / n := by
      intro n
      exact (h n).right
    have h₄ : BddAbove x := by
      apply BddAbove.exists_nat_le_of_forall_lt
      intro a
      specialize h₂ a
      specialize h₃ a
      calc
        _ < x a + 1 / a := by linarith
        _ ≤ x a + 1 := by
          have : a⁻¹ ≤ 1 := by
            calc
              _ ≤ (1 : ℝ)⁻¹ := by apply inv_le_inv <;> linarith
              _ = 1 := by simp
          rw [inv_eq_one_div] at this
          linarith
    have h₅ : BddBelow x := by
      apply BddBelow.exists_left_le_of_forall_lt
      intro a
      by_cases h : a = 0
     . simp [h]
     . have : a⁻¹ > 0 := by
          apply inv_pos_of_pos
          linarith
        rw [<-inv_eq_one_div a]
        linarith
    exact ⟨h₄, h₅⟩

  -- a sequence both of whose terms are bounded above and below, is bounded
  have x_bdd' {x : ℕ → ℝ} (h : ∀ n, 0 < x n ∧ x n < x (n + 1) ∧ x (n + 1