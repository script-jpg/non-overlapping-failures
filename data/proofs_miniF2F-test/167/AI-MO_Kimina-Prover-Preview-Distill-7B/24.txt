-- lemma, if gravity is bounded, then functional sequence is bounded.
  have l_bdd (x a : ℝ) (h₀ : f 1 x = x) (h₁ : ∀ x n, f (n + 1) x = f n x * (f n x + 1 / n))
      (h₂ : ∀ n, 0 < n → 0 < f n x ∧ f n x < a) : ∀ n, 0 < n → f n x < a := by
    intro k hk
    induction k with
    | zero => linarith
    | succ k ih =>
      by_cases h : k = 0
      · rw [h₀]
        linarith
      · have : k < k + 1 := by exact Nat.lt_add_one k
        have hk : 0 < f (k + 1) x := by
          have : 0 < f k x := by
            apply ih
            linarith
          apply h₁
          linarith
        have : f (k + 1) x < a := by
          apply h₁
          apply ih
          linarith
        linarith

  -- lemma, if gravity is bounded, then functional sequence is monotone.
  have l_mono (x a : ℝ) (h₀ : f 1 x = x) (h₁ : ∀ x n, f (n + 1) x = f n x * (f n x + 1 / n))
      (h₂ : ∀ n, 0 < n → 0 < f n x ∧ f n x < a) : ∀ n, 0 < n → f n x < f (n + 1) x := by
    intro k hk
    induction k with
    | zero => linarith
    | succ k ih =>
      by_cases h : k = 0
      · rw [h₀]
        linarith
      · have : k < k + 1 := by exact Nat.lt_add_one k
        have hk : 0 < f (k + 1) x := by
          have : 0 < f k x := by
            apply h₂ k
            linarith
          apply h₁
          linarith
        have h3 : f (k + 1) x < a := by
          apply h₂ (k + 1)
          linarith
        have h4 : f k x < a := by
          apply h₂ k
          linarith
        have h5 : f k x < f (k + 1) x := by
          rw [h₁]
          have : f k x + 1 / k > 0 := by
            apply add_pos
            apply h₂ k
            linarith
            apply one_div_pos.mpr
            linarith
          apply mul_lt_mul_of_pos_left
         . exact this
         . linarith
        linarith

  -- lemma, if gravity is bounded, then functional sequence is constant.
  have l_const (x a : ℝ) (h₀ : f 1 x = x) (h₁ : ∀ x n, f (n + 1) x = f n x * (f n x + 1 / n))
      (h₂ : ∀ n, 0 < n → 0 < f n x ∧ f n x < a) : ∀ n, 0 < n → f n x = f (n + 1) x := by
    intro k hk
    by_cases h : k = 1
    · rw [h, h₀]
    · have : k < k + 1 := by exact Nat.lt_add_one k
      have hk : 0 < f (k + 1) x := by
        have : 0 < f k x := by
          apply h₂ k
          linarith
        apply h₁
        linarith
      have h3 : f (k + 1) x < a := by
        apply h₂ (k + 1)
        linarith
      have h4 : f k x < a := by
        apply h₂ k
        linarith
      have h5 : f k x < f (k + 1) x := by
        rw [h₁]
        have : f k x + 1 / k > 0 := by
          apply add_pos
          apply h₂ k
          linarith
          apply one_div_pos.mpr
          linarith
        apply mul_lt_mul_of_pos_left
       . exact this
       . linarith
      have h6 : f (k + 1) x < f k x := by
        rw [h₁]
        have : f k x + 1 / k > 0 := by
          apply add_pos
          apply h₂ k
          linarith
          apply one_div_pos.mpr
          linarith
        have : f k x * (f k x + 1 / k) < f k x := by
          apply mul_lt_mul_of_pos_left
         . exact this
         . linarith
        linarith
      linarith

  -- define the gravity of sequence.
  let gravity (x : ℝ) : Prop := ∀ n, 0 < n → 0 < f n x ∧ f n x < f (n + 1) x ∧ f (n + 1) x < 1

  -- if gravity is bounded, then it must be constant.
  have l_bdd' (x a : ℝ) (h₀ : f 1 x = x) (h₁ : ∀ x n, f (n + 1) x = f n x * (f n x + 1 / n))
      (h₂ : ∀ n, 0 < n → 0 < f n x ∧ f n x < a) : ∀ n, 0 < n → f n x = f (n + 1) x := by
    intro k hk
    by_cases h : k = 1
    · rw [h, h₀]
    · have : k < k + 1 := by exact Nat.lt_add_one k
      have hk : 0 < f (k + 1) x := by
        have : 0 < f k x := by
          apply h₂ k
          linarith
        apply h₁
        linarith
      have h3 : f (k + 1) x < a := by
        apply h₂ (k + 1)
        linarith
      have h4 : f k x < a := by
        apply h₂ k
        linarith
      have h5 : f k x < f (k + 1) x := by
        rw [h₁]
        have : f k x + 1 / k > 0 := by
          apply add_pos
          apply h₂ k
          linarith
          apply one_div_pos.mpr
          linarith
        apply mul_lt_mul_of_pos_left
       . exact this
       . linarith
      have h6 : f (k + 1) x < f k x := by
        rw [h₁]
        have : f k x + 1 / k > 0 := by
          apply add_pos
          apply h₂ k
          linarith
          apply one_div_pos.mpr
          linarith
        have : f k x * (f k x + 1 / k) < f k x := by
          apply mul_lt_mul_of_pos_left
         . exact this
         . linarith
        linarith
      linarith

  -- if gravity is constant, then it must be less than one.
  have l_const' (x : ℝ) (h₀ : f 1 x = x) (h₁ : ∀ x n, f (n + 1) x = f n x * (f n x + 1 / n))
      (h₂ : ∀ n, 0 < n → n < m → f n x = f m x) : f 1 x < 1 := by
    have h3 : f 1 x < f 2 x := by
      rw [h₁]
      have : f 1 x + 1 > 0 := by
        linarith [h₀]
      apply mul_lt_mul_of_pos_left
     . exact this
     . linarith
    have h4 : f 2 x < f 1 x := by
      rw [h₁, h₂ 1 (by norm_num) 2 (by norm_num), h₀]
      have : f 1 x + 1 > 0 := by
        linarith [h₀]
      apply mul_lt_mul_of_pos_left
     . exact this
     . linarith
    linarith

  -- We will prove that the desired value of x is less than 1, and the gravity of x is monotone.
  refine ⟨?_,?_⟩
  · -- Use biconditional introduction to prove the "if" part of the goal.
    apply Iff.intro
    · intro hx
      -- Prove that gravity of x is monotone.
      have h_mono : ∀ n, 0 < n → f n x < f (n + 1) x := by
        intro n hn
        by_cases h : n = 1
        · rw [h, hx]
        · have : n < n + 1 := by exact Nat.lt_add_one n
          have hn : 0 < f n x := by
            apply hx n
            linarith
          have h := hx (n + 1) (by linarith)
          apply h₁
          apply hn
          linarith
      -- Define the sequence of sets.
      let S (n : ℕ) : Set ℝ := { x : ℝ | x > 0 ∧ f n x < x ∧ x < 1 ∧ (∀ n < n + 1, f n x < f (n + 1) x) }

      -- Prove that S is a monotonically increasing function.
      have h_S_mono : MonotoneOn S (fun x y => x < y) := by
        intro x hx y hy hxy
        simp only [Set.mem_setOf_eq] at hx hy
        suffices h : x < 1 ∧ f x x < 1 ∧ x < y ∧ f x y < f (x + 1) y ∧ f x x < f x y by
          rcases h with ⟨h1, h2, h3, h4, h5⟩
          apply And.intro h3
          apply And.intro h4
          apply And.intro h5
          exact h1
        apply And.intro hy
        apply And.intro hxy
        constructor
        · -- Prove that x < 1.
          apply h1
        · -- Prove that f x x < f x y.
          rw [h₁]
          apply mul_lt_mul_of_pos_left
         . exact hx
         . linarith
      -- Prove that S is bounded.
      have h_bdd : BddAbove (S 1) (fun x y => x < y) 1 := by
        refine ⟨?_,?_⟩
        · use 1
          simp only [Set.mem_setOf_eq]
          constructor
          · exact h₀
          · exact hx 1 (by norm_num)
        · intro x hx y hy hxy
          simp only [Set.mem_setOf_eq] at hx hy
          have h1 := hx.2.2.2
          have h2 := hy.2.2.2
          have h3 := hx.2.2.1
          have h4 := hy.2.2.1
          apply And.intro h3
          apply And.intro h4
          linarith
      -- Apply the lemma for monotone functions to show that S n = S 1.
      have h_S_eq : S 1 = S := by
        apply Eq.symm
        refine Equiv.monotoneOn_eq?_
        apply Equiv.monotoneOn_of_subset
        · simp only [Set.mem_setOf_eq]
          constructor
          · exact fun n hn => And.intro hn.2 hn.1
          · exact fun n hn => And.intro hn.2 hn.1
        · simp only [Set.mem_setOf_eq]
          intro x hx y hy hxy
          suffices h : x < 1 ∧ f x x < 1 ∧ x < y ∧ f x y < f (x + 1) y ∧ f x x < f x y by
            rcases h with ⟨h1, h2, h3, h4, h5⟩
            apply And.intro h3
            apply And.intro h4
            apply And.intro h5
            exact h1
          apply And.intro hy
          apply And.intro hxy
          constructor
          · exact h1
          · rw [h₁]
            apply mul_lt_mul_of_pos_left
           . exact hx
           . linarith
      -- Define the sequence of real numbers.
      let a (n : ℕ) : ℝ := sup (S (n + 1))

      -- Prove that a is strictly monotone.
      have h_a_mono : StrictMono a := by
        intro n m h
        apply lt_of_le_of_lt (Set.le_sup (S (m + 1)) (S (n + 1)))
        simp only [Set.mem_setOf_eq]
        constructor
        · linarith
        · apply And.intro h.2
          apply And.intro h.1
          linarith

      -- Prove that a is bounded.
      have h_a_bdd : BddAbove (a '' Set.Ici 1) (fun x y => x < y) 1 := by
        simp only [Set.mem_image]
        refine ⟨?_,?_⟩
        · use 1
          simp only [Set.mem_setOf_eq]
          constructor
          · exact h₀
          · apply h₁
            exact h₀
        · intro x hx y hy hxy
          simp only [Set.mem_setOf_eq] at hx hy
          rcases hx with ⟨n, hn⟩
          rcases hy with ⟨m, hm⟩
          simp only [Set.mem_setOf_eq] at hn hm
          rw [← hn.1]
          apply h₁
          apply hn.2
          linarith

      -- Apply the lemma for monotone functions to show that a is constant.
      have h_a_const : ∀ n, 1 ≤ n → a n = a 1 := by
        intro n hn
        suffices h : a n ∈ (a '' Set.Ici 1) by
          simp only [Set.mem_image] at h
          rcases h with ⟨m, hm⟩
          simp only [Set.mem_setOf_eq] at hm
          apply h.1
          linarith
        use n
        constructor
        · apply Set.mem_Ici.mpr
          linarith
        · apply_fun a
          refine Equiv.monotoneOn_of_subset?_
          · exact MonotoneOn.monotoneOn h_a_mono
          · exact Set.image_subset (Set.Ici 1) (Set.Ici 1)
      -- Prove that a is strictly greater than 1.
      have h_a_gt : a 1 > 1 := by
        suffices h : a 1 ∈ (Set.Ioi 1) by
          simp only [Set.mem_Ioi] at h
          exact h
        rw [Set.mem_Ioi]
        simp only [Set.mem_image]
        use 1
        constructor
        · simp only [Set.mem_setOf_eq]
          constructor
          · exact h₀
          · exact hx 1 (by norm_num)
        · rw [h₀]
          linarith
      -- Define the sequence of real numbers.
      let b (n : ℕ) : ℝ := a 1 - (a 1 - b (n + 1)) / 2

      -- Prove that b is strictly monotone.
      have h_b_mono : StrictMono b := by
        intro n m h
        apply lt_of_le_of_lt (Set.le_sup (S 2) (S (m + 2)))
        simp only [Set.mem_setOf_eq]
        constructor
        · linarith
        · apply And.intro h.2
          apply And.intro h.1
          linarith

      -- Prove that b is unbounded.
      have h_b_unb : ¬ BddAbove (b '' Set.Ici 1) (fun x y => x < y) 1 := by
        intro h
        have h_bdd : BddAbove (b '' Set.Ici 1) (fun x y => x < y) 1 := by
          apply h
        have h_b_eq : ∀ n ≥ 1, b n = 1 := by
          intro n hn
          suffices h : b n ∈ (b '' Set.Ici 1) by
            simp only [Set.mem_image] at h
            rcases h with ⟨m, hm⟩
            rcases hm with ⟨hn, hnm⟩
            rw [← hnm]
            apply_fun b
            refine Equiv.monotoneOn_of_subset?_
            · exact MonotoneOn.monotoneOn h_b_mono
            · exact Set.image_subset (Set.Ici 1) (Set.Ici 1)
          use n
          constructor
          · apply Set.mem_Ici.mpr
            linarith
          · apply_fun b
            simp only [Set.mem_setOf_eq]
            constructor
            · exact hn
            · linarith
        have h_b_eq' : b 1 = 1 := by
          have := h_b_eq 1 (by norm_num)
          exact this
        linarith

      -- Define the function that represents the set of b.
      let f' (x : ℝ) : Prop :=
        ∀ n, 0 < n → (b n < x ∧ x < b (n + 1)) ∨ (x = b n ∨ x = b (n + 1)) ∨ (x < b n ∧ b (n + 1) < x)

      -- Prove that f' is monotone.
      have h_f'_mono : MonotoneOn f' (fun x y => x < y) := by
        intro x hx y hy hxy
        simp only [Set.mem_setOf_eq] at hx hy
        intro n hn
        rcases hx with ⟨h1, h2⟩ | ⟨h1, h2⟩ | ⟨h1, h2⟩
        · constructor
          · apply lt_of_lt_of_le h1
            apply h_b_mono
            linarith
          · apply le_trans h2
            apply h_b_mono
            linarith
        ·