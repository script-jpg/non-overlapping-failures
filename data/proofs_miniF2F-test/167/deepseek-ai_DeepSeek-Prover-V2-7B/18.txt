use 1 / 2
  constructor
  · intro n hn
    have h₂ : ∀ n : ℕ, 0 < n → 0 < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction n with
      | zero => contradiction
      | succ n ih =>
        cases n with
        | zero =>
          norm_num [h₀, h₁]
        | succ n =>
          simp_all [h₀, h₁, div_eq_mul_inv]
          <;> norm_num <;>
            ring_nf at * <;>
            norm_num <;>
            nlinarith
    exact h₂ n hn
  · intro y hy
    have h₃ := hy 1 (by norm_num)
    have h₄ := hy 2 (by norm_num)
    have h₅ := hy 3 (by norm_num)
    norm_num [h₀, h₁] at h₃ h₄ h₅
    <;>
    (try norm_num) <;>
    (try linarith) <;>
    (try nlinarith) <;>
    (try nlinarith [sq_nonneg (y - 1 / 2)]) <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4)])
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8)])
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8), sq_nonneg (y ^ 4 - 1 / 16)])
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8), sq_nonneg (y ^ 4 - 1 / 16), sq_nonneg (y ^ 5 - 1 / 32)])
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8), sq_nonneg (y ^ 4 - 1 / 16), sq_nonneg (y ^ 5 - 1 / 32), sq_nonneg (y ^ 6 - 1 / 64)])
    <;>
    (try field_simp at *) <;>
    (try ring_nf at *) <;>
    (try nlinarith)
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8), sq_nonneg (y ^ 4 - 1 / 16), sq_nonneg (y ^ 5 - 1 / 32), sq_nonneg (y ^ 6 - 1 / 64)])
    <;>
    (try nlinarith [sq_nonneg (y - 1 / 2), sq_nonneg (y ^ 2 - 1 / 4), sq_nonneg (y ^ 3 - 1 / 8), sq_nonneg (y ^ 4 - 1 / 16), sq_nonneg (y ^ 5 - 1 / 32), sq_nonneg (y ^ 6 - 1 / 64), sq_nonneg (y ^ 7 - 1 / 128)])
    <;>
    nlinarith
```