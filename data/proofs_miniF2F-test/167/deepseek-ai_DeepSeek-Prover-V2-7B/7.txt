use 1 / 2
  constructor
  · intro n hn
    have h₂ : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction' hn with n hn
      · norm_num [h₀, h₁]
      · simp_all [h₀, h₁, div_eq_mul_inv]
        <;> ring_nf
        <;> norm_num
        <;>
        (try constructor) <;>
        (try norm_num) <;>
        (try linarith) <;>
        (try
          {
            nlinarith
          }) <;>
        (try
          {
            ring_nf
            <;> norm_num
            <;> nlinarith
          })
    simpa using h₂ n hn
  · intro y hy
    have h₃ : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n y ∧ f n y < f (n + 1) y ∧ f (n + 1) y < 1 := by
      intro n hn
      simpa using hy n hn
    have h₄ : y = 1 / 2 := by
      have h₅ := h₃ 1 (by norm_num)
      have h₆ := h₃ 2 (by norm_num)
      have h₇ := h₃ 3 (by norm_num)
      norm_num [h₀, h₁] at h₅ h₆ h₇
      <;>
      (try ring_nf at h₅ h₆ h₇) <;>
      (try norm_num at h₅ h₆ h₇) <;>
      (try nlinarith) <;>
      (try linarith) <;>
      (try nlinarith) <;>
      (try linarith) <;>
      (try nlinarith) <;>
      (try linarith)
    simp_all
```