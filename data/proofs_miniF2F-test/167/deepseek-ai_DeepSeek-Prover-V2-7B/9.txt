have h₂ : ∃! a, ∀ n, 0 < n → 0 < f n a ∧ f n a < f (n + 1) a ∧ f (n + 1) a < 1 := by
    use 1 / 2
    constructor
    · intro n hn
      have h₃ : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
        intro n hn
        induction n with
        | zero => contradiction
        | succ n ih =>
          cases n with
          | zero =>
            norm_num [h₀, h₁]
            <;> norm_num
            <;> ring_nf
            <;> norm_num
            <;> linarith
          | succ n =>
            simp_all [h₀, h₁]
            <;> norm_num at * <;>
            (try constructor) <;>
            (try norm_num) <;>
            (try ring_nf at * ) <;>
            (try field_simp at * ) <;>
            (try rw [← sub_pos] at * ) <;>
            (try field_simp [sub_pos] at * ) <;>
            (try ring_nf at * ) <;>
            (try nlinarith)
            <;>
            (try linarith)
            <;>
            (try nlinarith)
      exact h₃ n hn
    · intro y hy
      have h₃ := hy 1 (by norm_num)
      have h₄ := hy 2 (by norm_num)
      have h₅ := hy 3 (by norm_num)
      have h₆ := h₁ 1 1
      have h₇ := h₁ 1 2
      have h₈ := h₁ 2 1
      have h₉ := h₁ 2 2
      have h₁₀ := h₁ 3 1
      have h₁₁ := h₁ 3 2
      have h₁₂ := h₁ 4 1
      have h₁₃ := h₁ 4 2
      norm_num [h₀] at *
      <;> ring_nf at * <;> norm_num at * <;>
      (try nlinarith) <;>
      (try linarith) <;>
      (try nlinarith) <;>
      (try simp_all [mul_assoc]) <;>
      (try nlinarith) <;>
      (try linarith)
      <;>
      (try field_simp at *) <;>
      (try nlinarith) <;>
      (try linarith)
  exact h₂