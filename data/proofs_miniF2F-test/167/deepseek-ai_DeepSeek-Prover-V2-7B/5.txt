use 1 / 2
  constructor
  · intro n hn
    have h₂ : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction' n with n ih
      · simp_all [h₀, h₁]
        <;> norm_num
      · simp_all [h₀, h₁, mul_comm]
        <;> norm_num <;>
        (try
          ring_nf at * <;>
          norm_num <;>
          nlinarith) <;>
        (try
          field_simp at * <;>
          norm_num <;>
          nlinarith) <;>
        (try
          norm_num at * <;>
          nlinarith)
    simpa using h₂ n hn
  · intro y hy
    have h₃ := hy 1 (by norm_num)
    have h₄ := hy 2 (by norm_num)
    have h₅ := hy 3 (by norm_num)
    have h₆ := h₀ 1
    have h₇ := h₁ 1 1
    have h₈ := h₁ 1 2
    have h₉ := h₁ 1 3
    norm_num at *
    <;>
    (try
      simp_all [h₀, h₁]) <;>
    (try
      ring_nf at * <;>
      norm_num at * <;>
      nlinarith) <;>
    (try
      field_simp at * <;>
      norm_num at * <;>
      nlinarith) <;>
    (try
      norm_num at * <;>
      nlinarith)
    <;>
    aesop
```