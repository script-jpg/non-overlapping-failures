use 1 / 2
  constructor
  · intro n hn
    have h₂ : ∀ n : ℕ, 0 < n → 0 < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction n with
      | zero => contradiction
      | succ n ih =>
        cases n with
        | zero =>
          norm_num [h₀, h₁]
        | succ n =>
          simp_all [h₀, h₁, mul_add, mul_one, Nat.cast_add, Nat.cast_one, Nat.cast_succ]
          <;>
          ring_nf at *
          <;>
          norm_num at *
          <;>
          (try constructor) <;>
          (try norm_num) <;>
          (try linarith) <;>
          (try field_simp at *) <;>
          (try norm_num) <;>
          (try linarith)
    exact h₂ n hn
  · intro y hy
    have h₂ : ∀ n : ℕ, 0 < n → 0 < f n y ∧ f n y < f (n + 1) y ∧ f (n + 1) y < 1 := by
      intro n hn
      exact hy n hn
    have h₃ : y = 1 / 2 := by
      have h₄ := h₂ 1 (by norm_num)
      have h₅ := h₂ 2 (by norm_num)
      have h₆ := h₂ 3 (by norm_num)
      norm_num [h₀, h₁] at h₄ h₅ h₆
      <;>
      ring_nf at *
      <;>
      norm_num at *
      <;>
      nlinarith
    exact h₃