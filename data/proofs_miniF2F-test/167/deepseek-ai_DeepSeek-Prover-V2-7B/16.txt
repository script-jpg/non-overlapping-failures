use 1 / 2
  constructor
  · intro n hn
    have h : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction' n with n ih
      · simp_all [h₀, h₁]
        <;> norm_num
      · simp_all [h₀, h₁, ih]
        <;> norm_num <;> ring_nf <;> norm_num <;>
        (try
          {
            nlinarith [pow_pos (by norm_num : (0 : ℝ) < 1 / 2) n]
          }) <;>
        (try
          {
            field_simp [pow_succ]
            <;> ring_nf
            <;> norm_num
            <;> nlinarith [pow_pos (by norm_num : (0 : ℝ) < 1 / 2) n]
          })
    simpa using h n hn
  · intro y hy
    have h : ∀ n : ℕ, 0 < n → (0 : ℝ) < f n y ∧ f n y < f (n + 1) y ∧ f (n + 1) y < 1 := by
      intro n hn
      exact hy n hn
    have h₁ := h 1 (by norm_num)
    have h₂ := h 2 (by norm_num)
    have h₃ := h 3 (by norm_num)
    norm_num [h₀, h₁, h₂, h₃] at *
    <;> nlinarith [pow_pos (by norm_num : (0 : ℝ) < 1 / 2) 2,
      pow_pos (by norm_num : (0 : ℝ) < 1 / 2) 3]

  <;> norm_num
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;