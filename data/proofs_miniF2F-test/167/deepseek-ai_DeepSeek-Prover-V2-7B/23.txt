use 1 / 2
  constructor
  · intro n hn
    have h₂ : ∀ n : ℕ, 0 < n → 0 < f n (1 / 2) ∧ f n (1 / 2) < f (n + 1) (1 / 2) ∧ f (n + 1) (1 / 2) < 1 := by
      intro n hn
      induction' hn with n hn
      · norm_num [h₀, h₁]
      · simp_all [h₀, h₁, div_eq_mul_inv]
        <;> norm_num <;> ring_nf <;> norm_num <;>
        (try
          {
            nlinarith
          }) <;>
        (try
          {
            nlinarith [sq_nonneg (1 / 2 - 1 / 3)]
          }) <;>
        (try
          {
            nlinarith [sq_nonneg (1 / 2 + 1 / 3)]
          })
    exact h₂ n hn
  · intro y hy
    have h₃ := hy 1 (by norm_num)
    have h₄ := hy 2 (by norm_num)
    have h₅ := hy 3 (by norm_num)
    have h₆ := h₁ 0 0
    have h₇ := h₁ 0 1
    have h₈ := h₁ 1 0
    have h₉ := h₁ 1 1
    have h₁₀ := h₁ 2 0
    have h₁₁ := h₁ 2 1
    have h₁₂ := h₁ 3 0
    have h₁₃ := h₁ 3 1
    norm_num [h₀, h₁] at *
    <;> nlinarith