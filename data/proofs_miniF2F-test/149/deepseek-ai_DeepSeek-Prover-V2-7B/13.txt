have h₀ : (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
    by_cases h : n = 0
    · subst h
      norm_num
      <;> simp_all [Nat.cast_zero]
      <;> norm_num
    · cases n with
      | zero => contradiction
      | succ k =>
        cases k with
        | zero =>
          norm_num
          <;> field_simp [Nat.cast_one]
          <;> ring_nf
          <;> norm_num
        | succ k' =>
          have h₁ : 0 < (n : ℝ) := by positivity
          have h₂ : (n : ℝ) ≥ 1 := by
            norm_cast
            linarith [Nat.succ_le_iff.mpr (Nat.succ_pos k')]
          have h₃ : (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
            have h₄ : (n : ℝ) ≥ 1 := by assumption
            have h₅ : (1 : ℝ) / n ≥ 0 := by positivity
            have h₆ : (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
              calc
                (n : ℝ) ^ ((1 : ℝ) / n) ≤ (n : ℝ) ^ (1 : ℝ) := by
                  apply Real.rpow_le_rpow_of_exponent_le
                  · assumption
                  ·
                    have : (1 : ℝ) / n ≤ 1 := by
                      apply div_le_one_of_le
                      ·
                        norm_cast
                        linarith [Nat.succ_le_iff.mpr (Nat.succ_pos k')]
                      · positivity
                    linarith
                _ = n := by simp
                _ < 2 - 1 / n := by
                  have : (n : ℝ) ≥ 2 := by
                    norm_cast
                    linarith [Nat.succ_le_iff.mpr (Nat.succ_pos k')]
                  have : (1 : ℝ) / n > 0 := by positivity
                  nlinarith
            assumption
          assumption
  simpa using h₀
```