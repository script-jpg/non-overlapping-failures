have h : (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
    have h₁ : n ≥ 2 → (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
      intro hn
      have h2 : (n : ℝ) ≥ 2 := by exact_mod_cast hn
      have h3 : (1 : ℝ) / n ≤ 1 := by
        apply div_le_one_of_le
        <;> norm_num <;> nlinarith
        <;> nlinarith
      have h4 : (n : ℝ) ^ ((1 : ℝ) / n) < 2 - 1 / n := by
        calc
          (n : ℝ) ^ ((1 : ℝ) / n) < 2 ^ ((1 : ℝ) / n) := by gcongr <;> nlinarith
          _ ≤ 2 - 1 / n := by
            have h5 : (2 : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / n := by
              have h6 : (1 : ℝ) / n ≤ 1 := by
                apply div_le_one_of_le
                <;> norm_num <;> nlinarith
                <;> nlinarith
              have h7 : (2 : ℝ) ^ ((1 : ℝ) / n) ≤ 2 - 1 / n := by
                -- Use the fact that 2^x ≤ 2 - x for x ∈ (0,1)
                have h8 : (1 : ℝ) / n ≤ 1 := by
                  apply div_le_one_of_le
                  <;> norm_num <;> nlinarith
                  <;> nlinarith
                calc
                  (2 : ℝ) ^ ((1 : ℝ) / n) ≤ 2 ^ (1 : ℝ) := Real.rpow_le_rpow_of_exponent_le (by norm_num) h8
                  _ = 2 := by norm_num
                  _ ≤ 2 - 1 / n + 1 / n := by nlinarith
                  _ ≤ 2 - 1 / n := by nlinarith
              exact h7
            nlinarith
      exact h4
    by_cases hn : n ≥ 2
    · exact h₁ hn
    · interval_cases n <;> norm_num at * <;> norm_num <;>
      simp_all [Nat.div_eq_of_lt] <;>
      norm_num <;>
      apply lt_of_sub_pos <;> field_simp <;>
      ring_nf <;>
      nlinarith
  
  exact h
```