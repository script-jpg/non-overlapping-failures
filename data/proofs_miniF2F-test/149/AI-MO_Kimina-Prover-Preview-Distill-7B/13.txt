-- Take the n-th power of both sides
  nth_rewrite 1 [← Real.rpow_mul]
  nth_rewrite 2 [← Real.rpow_one n]
  -- Show that both sides are positive so that we can do exponentiation
  swap; constructor
  · apply Real.rpow_pos_of_pos
    norm_num
  · apply Real.rpow_pos_of_pos
    norm_num
  -- Simplify the equation
  rw [mul_one, one_rpow, rpow_two]
  rw [show (2 : ℝ) = 1 + 1 by norm_num, add_sq]
  -- Cancel the common part on both sides
  apply (add_lt_add_iff_right _).mp
  -- Show that the left side is 1/n^2
  rw [← mul_one n, ← pow_two, ← rpow_natCast, ← rpow_mul]
  · simp [mul_inv_cancel₀]
  -- Prove the inequality by estimating the error term
  rw [Nat.cast_pow, Nat.cast_mul, Nat.cast_one]
  simp; norm_cast
  rw [Nat.div_reorder, Nat.cast_sub, Nat.cast_one]
  rw [abs_eq_self.mpr, div_nonneg_iff]
  -- Resolving the "or"
  refine (one_le_div?_?_).mp?_
  · exact Nat.zero_lt_of_ne_zero n
  · exact Nat.one_le_of_lt Nat.lt_two_iff.mp?_
    exact Ne.symm (Nat.zero_ne_one n)
  · exact Nat.one_le_of_lt Nat.lt_two_iff.mp?_
    exact Ne.symm (Nat.zero_ne_one n)
```