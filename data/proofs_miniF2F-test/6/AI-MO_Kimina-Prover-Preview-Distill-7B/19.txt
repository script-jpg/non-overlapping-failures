-- some auxiliary statements
  have h₄: y m = 0 := h₂
  have h₅: y n = 0 := h₃
  have h₆: ∀ i ∈ Finset.range k, 0 ≤ Real.cos (a i + m) / 2 ^ i := by
    intro i _
    positivity
  have h₇: ∀ i ∈ Finset.range k, 0 ≤ Real.cos (a i + n) / 2 ^ i := by
    intro i _
    positivity

  -- write y m = 0 as a product of cos (a i + m) / 2 ^ i = 0
  have h₈: ∏ i in Finset.range k, (Real.cos (a i + m) / 2 ^ i) = 0 := by
    rw [Finset.prod_eq_zero_iff]
    refine ⟨h₄,?_⟩
    intro h
    simp [Finset.prod_pos_iff] at h
    each_goals { linarith [h₆ i h]}

  -- the following statement will be used later
  have h₉: ∀ i ∈ Finset.range k, Real.cos (a i + m) / 2 ^ i = 0 := by
    intro i _
    have : 0 ≤ Real.cos (a i + m) / 2 ^ i := h₆ i
    have : Real.cos (a i + m) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₈
      simp at h₈
      exact h₈
    linarith

  -- write y n = 0 as a product of cos (a i + n) / 2 ^ i = 0
  have h₁₀: ∏ i in Finset.range k, (Real.cos (a i + n) / 2 ^ i) = 0 := by
    rw [Finset.prod_eq_zero_iff]
    refine ⟨h₅,?_⟩
    intro h
    simp [Finset.prod_pos_iff] at h
    each_goals { linarith [h₇ i h]}

  -- the following statement will be used later
  have h₁₁: ∀ i ∈ Finset.range k, Real.cos (a i + n) / 2 ^ i = 0 := by
    intro i _
    have : 0 ≤ Real.cos (a i + n) / 2 ^ i := h₇ i
    have : Real.cos (a i + n) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₁₀
      simp at h₁₀
      exact h₁₀
    linarith

  -- for simplicity, denote the product of cos (a i + m) / 2 ^ i by p
  set p := ∏ i in Finset.range k, (Real.cos (a i + m) / 2 ^ i)
  -- and denote the product of cos (a i + n) / 2 ^ i by q
  set q := ∏ i in Finset.range k, (Real.cos (a i + n) / 2 ^ i)

  -- p = 0 and q = 0
  have h₁₂: p = 0 := h₈
  have h₁₃: q = 0 := h₁₀

  -- all terms of p is non-negative so p = 0 implies that all terms of p is 0
  have h₁₄: (∀ i ∈ Finset.range k, Real.cos (a i + m) / 2 ^ i = 0) := by
    intro i _
    have: 0 ≤ Real.cos (a i + m) / 2 ^ i := h₆ i
    have: Real.cos (a i + m) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₁₂
      simp at h₁₂
      exact h₁₂
    linarith

  -- all terms of q is non-negative so q = 0 implies that all terms of q is 0
  have h₁₅: (∀ i ∈ Finset.range k, Real.cos (a i + n) / 2 ^ i = 0) := by
    intro i _
    have: 0 ≤ Real.cos (a i + n) / 2 ^ i := h₇ i
    have: Real.cos (a i + n) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₁₃
      simp at h₁₃
      exact h₁₃
    linarith

  -- denote the sum of cos (a i + m) / 2 ^ i by s
  set s := ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i
  -- denote the sum of cos (a i + n) / 2 ^ i by t
  set t := ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i

  -- s = 0 and t = 0
  have h₁₆: s = 0 := by
    rw [←h₁]
    convert h₈
    simp only [p, Finset.prod_eq_zero_iff, Finset.mem_range, iff_false, zero_div, or_self]
  have h₁₇: t = 0 := by
    rw [←h₁]
    convert h₁₀
    simp only [q, Finset.prod_eq_zero_iff, Finset.mem_range, iff_false, zero_div, or_self]

  -- all terms of s is non-negative so s = 0 implies that all terms of s is 0
  have h₁₈: (∀ i ∈ Finset.range k, Real.cos (a i + m) / 2 ^ i = 0) := by
    intro i _
    have: 0 ≤ Real.cos (a i + m) / 2 ^ i := h₆ i
    have: Real.cos (a i + m) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₁₆
      simp at h₁₆
      exact h₁₆
    linarith

  -- all terms of t is non-negative so t = 0 implies that all terms of t is 0
  have h₁₉: (∀ i ∈ Finset.range k, Real.cos (a i + n) / 2 ^ i = 0) := by
    intro i _
    have: 0 ≤ Real.cos (a i + n) / 2 ^ i := h₇ i
    have: Real.cos (a i + n) / 2 ^ i = 0 := by
      apply_fun (· * 2 ^ i) at h₁₇
      simp at h₁₇
      exact h₁₇
    linarith

  -- the above conclusions can be basically be combined, so we have
  -- ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i = ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i
  have h₂₀: s = t := by
    rw [Finset.sum_congr rfl h₁₄, Finset.sum_congr rfl h₁₉, h₁₆, h₁₇]

  -- but this is a contradiction except for m - n is a multiple of π
  have h₂₁: s ≠ t := by
    rw [Finset.sum_congr rfl h₄, h₅, h₁₆, h₁₇]
    have: Real.cos (a 0 + m) / 2 ^ 0 ≠ 0 := by
      push_cast
      simp only [ne_eq, false_eqiff]
      positivity
    simp only [div_zero, every_or_left] at this
    apply this
    exact fun a => rfl

  -- so we have proved that m - n is a multiple of π
  have h₂₂: m - n = (m - n) / Real.pi * Real.pi := by
    rw [div_mul_cancel₀ _ (by positivity)]
  rw [h₂₂]
  exact h₂₁ h₂₀

```