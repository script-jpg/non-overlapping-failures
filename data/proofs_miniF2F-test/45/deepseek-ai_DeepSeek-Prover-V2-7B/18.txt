have step₁ : (∑ k in S, k) = 2016 := by
    have h₁ : S = {2016} := by
      ext n
      simp only [h₀, Finset.mem_singleton, Finset.mem_filter, Finset.mem_Icc]
      constructor
      · intro h
        rcases h with ⟨h₁, h₂, ⟨m, hm, hsum⟩⟩
        have h₃ : n = 2016 := by
          have h₄ : m ≤ 2019 := by
            by_contra h
            have h₅ : m ≥ 2020 := by linarith
            have h₆ : (∑ p in Nat.divisors m, p) ≥ m := by
              have h₇ : m ∈ Nat.divisors m := by
                exact Nat.mem_divisors.mpr ⟨Nat.dvd_refl m, by linarith⟩
              have h₈ : (∑ p in Nat.divisors m, p) ≥ m := by
                exact Finset.single_le_sum (fun x _ => Nat.zero_le x) h₇
              exact h₈
            nlinarith
          interval_cases m <;> norm_num at hm hsum ⊢ <;>
            (try omega) <;>
            (try {
              try {
                have h₉ : n ≤ 2019 := by omega
                interval_cases n <;> norm_num at * <;>
                (try { omega }) <;>
                (try {
                  rcases m with (_ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _ | _) <;>
                  norm_num at * <;> simp_all (config := {decide := true}) <;>
                  omega
                })
              }
            }) <;> omega
        simp_all
      · intro h
        simp_all
        <;>
        (try {
          use 2016
          norm_num
          <;>
          rfl
        }) <;>
        (try {
          norm_num at *
          <;>
          use 2016
          <;>
          norm_num at *
          <;>
          aesop
        })
    rw [h₁]
    norm_num
    <;> rfl
  
  exact step₁
```