have step₁ : S = {2016} := by
    ext n
    simp only [h₀, Finset.mem_singleton, Finset.mem_Icc]
    constructor
    -- First direction: if n is in S, then n must be 2016.
    · rintro ⟨h₁, h₂, m, hm₁, hm₂⟩
      have h₃ : n = 2016 := by
        have h₄ : m ≤ 2019 := by omega
        have h₅ : m ≥ 1 := by
          by_contra h
          simp_all [Nat.divisors]
          <;> omega
        interval_cases m <;> norm_num [Nat.divisors] at hm₁ hm₂ <;>
        (try omega) <;> (try omega) <;> (try omega) <;> (try omega) <;>
        (try {
          simp_all (config := {decide := true})
          <;> aesop
        }) <;> (try omega) <;> aesop
      simp_all
    -- Second direction: if n is 2016, then n is in S.
    · rintro rfl
      refine ⟨by norm_num, by norm_num, 225,?_,?_⟩ <;>
        norm_num [Nat.divisors] <;>
        rfl
  
  have step₂ : (∑ k in S, k) = 2016 := by
    rw [step₁]
    norm_num
    <;> rfl
  
  rw [step₁] at *
  norm_num at *
  <;> simp_all
  <;> aesop
  <;> norm_num
  <;> rfl
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop
  <;> aesop