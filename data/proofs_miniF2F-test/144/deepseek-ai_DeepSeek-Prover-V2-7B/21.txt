have h₁ := h₀
  rw [Complex.normSq_apply] at h₀ h₁
  simp_all [Complex.normSq_apply, Complex.ext_iff, pow_two, mul_add, mul_comm, mul_left_comm]
  ring_nf at h₀ h₁ ⊢
  norm_cast at h₀ h₁ ⊢
  have h₂ : z ≠ 0 := by
    intro h
    simp [h] at h₀ h₁
    <;> ring_nf at h₀ h₁ ⊢ <;> nlinarith
  field_simp [h₂] at h₀ h₁ ⊢
  <;> nlinarith [sq_nonneg (z.re - 1), sq_nonneg (z.re + 1), sq_nonneg (z.im - 1), sq_nonneg (z.im + 1),
    sq_nonneg (z.re - 2), sq_nonneg (z.re + 2), sq_nonneg (z.im - 2), sq_nonneg (z.im + 2)]

  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith

theorem amc12b_2021_p18' (z : ℂ)
    (h₀ : 12 * Complex.normSq z = 2 * Complex.normSq (z + 2) + Complex.normSq (z ^ 2 + 1) + 31) :
    z + 6 / z = -2 := by
  have h₁ := h₀
  rw [Complex.normSq_apply] at h₀ h₁
  simp_all [Complex.normSq_apply, Complex.ext_iff, pow_two, mul_add, mul_comm, mul_left_comm]
  ring_nf at h₀ h₁ ⊢
  norm_cast at h₀ h₁ ⊢
  have h₂ : z ≠ 0 := by
    intro h
    simp [h] at h₀ h₁
    <;> ring_nf at h₀ h₁ ⊢ <;> nlinarith
  field_simp [h₂] at h₀ h₁ ⊢
  <;> nlinarith [sq_nonneg (z.re - 1), sq_nonneg (z.re + 1), sq_nonneg (z.im - 1), sq_nonneg (z.im + 1),
    sq_nonneg (z.re - 2), sq_nonneg (z.re + 2), sq_nonneg (z.im - 2), sq_nonneg (z.im + 2)]
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith
  <;> nlinarith