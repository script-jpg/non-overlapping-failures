have h₁ : z ≠ 0 := by
    intro h
    rw [h] at h₀
    simp [Complex.normSq] at h₀
    <;> norm_num at h₀ <;> nlinarith
  
  have h₂ : z + 6 / z = -2 := by
    have h₃ : 12 * Complex.normSq z = 2 * Complex.normSq (z + 2) + Complex.normSq (z ^ 2 + 1) + 31 := h₀
    have h₄ : Complex.normSq z = z.re * z.re + z.im * z.im := by
      simp [Complex.normSq]
      <;> ring
    have h₅ : Complex.normSq (z + 2) = (z.re + 2) * (z.re + 2) + z.im * z.im := by
      simp [Complex.normSq, Complex.ext_iff]
      <;> ring
    have h₆ : Complex.normSq (z ^ 2 + 1) = (z.re ^ 2 - z.im ^ 2 + 1) ^ 2 + (2 * z.re * z.im) ^ 2 := by
      simp [Complex.normSq, Complex.ext_iff, pow_two, Complex.ext_iff]
      <;> ring_nf
      <;> simp_all [Complex.ext_iff, pow_two, Complex.ext_iff]
      <;> norm_num
      <;> nlinarith
    simp_all [Complex.normSq, Complex.ext_iff, pow_two, Complex.ext_iff]
    <;> ring_nf at *
    <;> apply And.intro <;>
    (try
      field_simp at * <;>
      nlinarith) <;>
    (try
      simp_all [Complex.ext_iff, pow_two, Complex.ext_iff]) <;>
    (try
      norm_num at * <;>
      nlinarith) <;>
    (try
      constructor <;>
      nlinarith)
  
  exact h₂
```