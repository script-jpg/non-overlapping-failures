have step₁ : z + 6 / z = -2 := by
    have h₁ := h₀
    simp [Complex.normSq, Complex.ext_iff, pow_two, mul_add, add_mul] at h₁ ⊢
    ring_nf at h₁ ⊢
    by_cases h : z.re = 0 <;> by_cases h' : z.im = 0 <;>
    simp_all [Complex.ext_iff, pow_two, mul_assoc, mul_comm, mul_left_comm] <;>
    (try {
      field_simp at * <;>
      ring_nf at * <;>
      nlinarith [sq_nonneg (z.re - 1), sq_nonneg (z.re + 1), sq_nonneg (z.re - 3),
        sq_nonneg (z.im - 2), sq_nonneg (z.im + 2), sq_nonneg (z.im - 1),
        sq_nonneg (z.im + 1), sq_nonneg (z.re ^ 2 + z.im ^ 2 - 3)] }) <;>
    (try {
      nlinarith [sq_nonneg (z.re - 1), sq_nonneg (z.re + 1), sq_nonneg (z.re - 3),
        sq_nonneg (z.im - 2), sq_nonneg (z.im + 2), sq_nonneg (z.im - 1),
        sq_nonneg (z.im + 1), sq_nonneg (z.re ^ 2 + z.im ^ 2 - 3)] }) <;>
    (try {
      apply And.intro <;>
      nlinarith [sq_nonneg (z.re - 1), sq_nonneg (z.re + 1), sq_nonneg (z.re - 3),
        sq_nonneg (z.im - 2), sq_nonneg (z.im + 2), sq_nonneg (z.im - 1),
        sq_nonneg (z.im + 1), sq_nonneg (z.re ^ 2 + z.im ^ 2 - 3)] })
    <;>
    (try {
      aesop })
  
  simpa using step₁
```