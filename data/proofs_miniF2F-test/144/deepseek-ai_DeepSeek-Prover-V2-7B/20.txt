have step₁ : z + 6 / z = -2 := by
    have h₁ : z ≠ 0 := by
      intro h
      rw [h] at h₀
      simp_all [Complex.normSq, pow_two]
      <;> ring_nf at * <;> norm_num at *
      <;> nlinarith [sq_nonneg (z.re + 2), sq_nonneg (z.im), sq_nonneg (z.re - 2),
        sq_nonneg (z.im + 2), sq_nonneg (z.im - 2)]
    field_simp [h₁] at h₀ ⊢
    simp_all [Complex.normSq, pow_two, Complex.ext_iff, mul_add, add_mul, mul_sub, sub_mul,
      mul_comm, mul_left_comm]
    <;> ring_nf at *
    <;> norm_num at *
    <;> apply And.intro <;>
    (try constructor) <;>
    (try nlinarith) <;>
    (try ring_nf at *) <;>
    (try nlinarith [sq_nonneg (z.re + 2), sq_nonneg (z.im), sq_nonneg (z.re - 2),
      sq_nonneg (z.im + 2), sq_nonneg (z.im - 2), sq_nonneg (z.re - 1),
      sq_nonneg (z.im - 1), sq_nonneg (z.re + 1), sq_nonneg (z.im + 1)])
    <;>
    (try
      {
        apply mul_left_cancel₀ (sub_ne_zero.mpr h₁.symm)
        ring_nf at *
        <;>
        simp_all [Complex.ext_iff, pow_two, pow_three]
        <;>
        ring_nf at *
        <;>
        nlinarith
      })
    <;>
    (try
      {
        apply mul_left_cancel₀ (sub_ne_zero.mpr h₁.symm)
        ring_nf at *
        <;>
        simp_all [Complex.ext_iff, pow_two, pow_three]
        <;>
        ring_nf at *
        <;>
        nlinarith
      })
  
  apply step₁
```