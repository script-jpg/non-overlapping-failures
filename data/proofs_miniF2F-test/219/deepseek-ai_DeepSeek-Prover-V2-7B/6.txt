have h₁ : ∀ n : ℕ, ¬5 ∣ ∑ k in Finset.range (n + 1), Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k) := by
    intro n
    apply Nat.not_dvd_of_pos_of_lt (by positivity)
    have h₂ : ∑ k in Finset.range (n + 1), Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k) % 5 = 2 ^ (2 * n + 1) % 5 := by
      have h₃ : ∀ n : ℕ, ∑ k in Finset.range (n + 1), Nat.choose (2 * n + 1) (2 * k + 1) * 2 ^ (3 * k) % 5 = 2 ^ (2 * n + 1) % 5 := by
        intro n
        induction n with
        | zero => simp [Finset.sum_range_succ, Nat.choose_zero_right, Nat.choose_one_right]
        | succ n ih =>
          simp_all [Finset.sum_range_succ, Nat.choose_succ_succ, pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod,
            Nat.add_mod, Nat.mod_eq_of_lt]
          <;>
            rcases n with (_ | _ | _ | _ | _) <;> simp [*, Finset.sum_range_succ, Nat.choose_succ_succ, pow_add,
              pow_mul, Nat.mul_mod, Nat.pow_mod, Nat.add_mod, Nat.mod_eq_of_lt] <;>
              omega
      exact h₃ n
    have h₄ : 2 ^ (2 * n + 1) % 5 ≠ 0 := by
      have h₅ : 2 ^ (2 * n + 1) % 5 = 2 ^ (2 * n + 1) % 5 := by rfl
      rw [h₅]
      have h₆ : 2 ^ (2 * n + 1) % 5 = 2 ^ (2 * n + 1) % 5 := by rfl
      rw [h₆]
      have h₇ : 2 ^ (2 * n + 1) % 5 = 2 ^ (2 * n + 1) % 5 := by rfl
      rw [h₇]
      have h₈ : 2 ^ (2 * n + 1) % 5 = 2 ^ (2 * n + 1) % 5 := by rfl
      rw [h₈]
      have h₉ : 2 ^ (2 * n + 1) % 5 ≠ 0 := by
        induction n with
        | zero => simp
        | succ n ih =>
          simp [pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod, Nat.add_mod, Nat.mod_eq_of_lt] at *
          <;> omega
      exact h₉
    omega
  exact h₁ n