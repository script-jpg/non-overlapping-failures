have hp : 1 < p := h₀.1
  have hq : 1 < q := by linarith
  have hr : 1 < r := by linarith

  have hpq : 1 < p * q := by nlinarith
  have hpr : 1 < p * r := by nlinarith
  have hqr : 1 < q * r := by nlinarith
  have hpprqr : 1 < p * q * r := by nlinarith

  have hpqr : 1 ≤ (p - 1) * (q - 1) * (r - 1) := by
    apply Int.le_of_dvd (by norm_num)
    apply Int.dvd_trans h₁
    apply Int.dvd_mul_right

  have h2 : (p - 1) * (q - 1) * (r - 1) > 0 := by
    apply Int.lt_of_le_of_ne
    · apply Int.le_of_dvd (by norm_num)
      apply Int.dvd_trans h₁
      apply Int.dvd_mul_right
    · by_contra!
      have : (p - 1) * (q - 1) * (r - 1) = 0 := by
        rw [this]
        simp
      have : p - 1 = 0 := by
        apply Int.eq_zero_of_ne_zero_of_mul_eq_zero_left (by linarith) this
      have : p = 1 := by omega
      linarith

  have h3 : p * q * r - 1 > 0 := by
    have : (p - 1) * (q - 1) * (r - 1) > 0 := h2
    linarith

  have hpq'r : p * q * r - 1 ≠ 0 := by
    by_contra!
    have : p * q * r = 1 := by omega
    have : p * q * r > 0 := by nlinarith
    have : p * q * r = 0 := by omega
    linarith

  have hpq' : p * q - 1 > 0 := by
    have : p * q * r - 1 > 0 := h3
    have : p * q * r > 0 := by nlinarith
    have : p * q * r - 1 < p * q * r := by omega
    omega

  have hp' : p - 1 > 0 := by
    have : p * q - 1 > 0 := hpq'
    have : p * q > 0 := by nlinarith
    have : p * q - 1 < p * q := by omega
    omega

  have hq' : q - 1 > 0 := by
    have : p * q - 1 > 0 := hpq'
    have : p * q > 0 := by nlinarith
    have : p * q - 1 < p * q := by omega
    omega

  have hr' : r - 1 > 0 := by
    have : p * q * r - 1 > 0 := h3
    have : p * q * r > 0 := by nlinarith
    have : p * q * r - 1 < p * q * r := by omega
    omega

  have ha : 1 < p * q * r := by nlinarith

  have hpq'' : (p - 1) * (q - 1) * (r - 1) < p * q * r := by
    calc
      (p - 1) * (q - 1) * (r - 1) < p * q * r - 1 := by
        apply Int.lt_sub_one
        linarith
      _ < p * q * r := by omega

  have h4 : (p - 1) * (q - 1) * (r - 1) ∣ p * q * r - 1 := h₁

  let x : ℕ := ((p * q * r - 1) / ((p - 1) * (q - 1) * (r - 1)) : ℤ)

  have hx : x = ((p * q * r - 1) / ((p - 1) * (q - 1) * (r - 1)) : ℤ) := by
    rfl

  have h5 : x > 0 := by
    rw [hx]
    apply Int.zero_lt_ediv
    · linarith
    · apply Int.dvd_trans h₁
      apply Int.dvd_mul_right

  have h6 : x * ((p - 1) * (q - 1) * (r - 1)) = p * q * r - 1 := by
    rw [hx]
    symm
    apply Int.ediv_mul_cancel
    · have : ((p - 1) * (q - 1) * (r - 1)) ≠ 0 := by
        apply Int.mul_ne_zero
        · apply Int.mul_ne_zero
          · apply ne_of_gt
            apply Int.sub_pos_of_lt
            linarith
          · apply ne_of_gt
            apply Int.sub_pos_of_lt
            linarith
        · apply ne_of_gt
          apply Int.sub_pos_of_lt
          linarith
      exact Int.ediv_mul_cancel₀ this

  have h7 : p * q * r - 1 ≠ 0 := by
    by_contra!
    have : p * q * r = 1 := by omega
    have : p * q * r > 0 := by nlinarith
    have : p * q * r = 0 := by omega
    linarith

  have h8 : x * ((p - 1) * (q - 1) * (r - 1)) ≠ 0 := by
    rw [h6]
    exact h7

  have h9 : x ≠ 0 := by
    by_contra!
    rw [this] at h8
    simp at h8

  have h10 : x * ((p - 1) * (q - 1) * (r - 1)) > 0 := by
    apply Int.mul_pos
    · exact h5
    · linarith

  have h11 : x > 0 := by
    by_contra!
    have : x ≤ 0 := by omega
    linarith

  have h12 : x * ((p - 1) * (q - 1) * (r - 1)) < p * q * r := by
    calc
      x * ((p - 1) * (q - 1) * (r - 1)) = p * q * r - 1 := h6
      _ < p * q * r := by omega

  have h13 : x < p * q * r := by
    by_contra!
    have : x ≥ p * q * r := by omega
    linarith

  have h14 : x * ((p - 1) * (q - 1) * (r - 1)) = p * q * r - 1 := by
    exact h6

  suffices (p, q, r) = (2, 4, 8) ∨ (p, q, r) = (3, 5, 15) by
    exact this

  have hp₀ : p ∣ p := by
    exact Int.dvd_refl p

  have hp₁ : p ∣ (p - 1) * (q - 1) * (r - 1) := by
    apply Int.dvd_mul_right

  have hp₂ : p ∣ p * q * r - 1 := by
    rw [h6]
    apply Int.dvd_mul_right

  have hp₃ : p ∣ (p * q * r - 1) % p := by
    apply Dvd.dvd.mod_dvd

  have hp₄ : (p * q * r - 1) % p = 0 := by
    have : p * q * r ≡ 0 [ZMOD p] := by
      simp [Int.ModEq]
      apply Int.dvd_iff_emod_eq_zero.mp
      exact hp₀
    have : p * q * r - 1 ≡ 0 - 1 [ZMOD p] := by
      apply Int.ModEq.sub_right
      exact this
    simp [Int.ModEq] at this
    exact this

  have hp₅ : (p * q * r - 1) % p = 0 := by
    exact hp₄

  have hpq'' : (p - 1) * (q - 1) * (r - 1) ∣ p * q * r - 1 := by
    exact h₁

  have hpq''' : (p - 1) * (q - 1) * (r - 1) ∣ (p * q * r - 1) % (p - 1) * (q - 1) * (r - 1) := by
    apply Int.dvd_mul_right

  have hpq'''' : (p - 1) * (q - 1) * (r - 1) ∣ (p * q * r - 1) % ((p - 1) * (q - 1) * (r - 1)) := by
    apply Dvd.dvd.mod_dvd
    exact hpq''

  have hpq''''' : (p - 1) * (q - 1) * (r - 1) ∣ 0 := by
    apply Int.dvd_zero

  have hpq'''''' : (p - 1) * (q - 1) * (r - 1) = 0 ∨ (p - 1) * (q - 1) * (r - 1) = 1 := by
    by_contra!
    have : (p - 1) * (q - 1) * (r - 1) > 1 := by omega
    have h1 : (p - 1) * (q - 1) * (r - 1) ∣ 0 := hpq'''''
    rcases (Int.dvd_iff_eq_int_mul_left (by linarith) h1) with ⟨k, hk⟩
    have h2 : k > 0 := by
      apply Int.lt_of_le_of_ne
      · apply Int.le_of_dvd (by norm_num)
        exact h1
      · by_contra!
        have : k = 0 := by omega
        rw [this] at hk
        simp at hk
        have : (p - 1) * (q - 1) * (r - 1) > 1 := by omega
        linarith
    have h3 : k < (p - 1) * (q - 1) * (r - 1) := by
      apply Int.lt_of_lt_of_le
      · by_contra!
        have : k ≥ (p - 1) * (q - 1) * (r - 1) := by omega
        linarith
      · apply Int.le_of_dvd
        · apply Int.dvd_trans (by norm_num)
          exact hpq''''
        · exact ne_of_gt h2
    linarith

  rcases hpq'''''' with h | h

  -- (p - 1) * (q - 1) * (r - 1) = 0 is impossible
  · have : (p - 1) * (q - 1) * (r - 1) > 0 := h2
    linarith

  -- (p - 1) * (q - 1) * (r - 1) = 1 is impossible
  · have : (p - 1) * (q - 1) * (r - 1) > 0 := h2
    linarith

```