have hp : 1 < p := h₀.1
  have hq : 1 < q := by linarith
  have hr : 1 < r := by linarith

  have hpqr : 1 < p * q * r := by
    apply one_lt_mul
    · apply one_lt_mul
      · exact hp
      · linarith
    · linarith
  have hv : 1 < p * q := by
    apply one_lt_mul
    · exact hp
    · linarith

  -- For easier manipulation of the divisibility relation, we will add 1 to both sides of the original divisibility relation.
  apply Int.dvd_add at h₁
  have h₂ : (p - 1) * (q - 1) * (r - 1) + 1 ∣ p * q * r := by
    convert h₁ using 1
    ring_nf

  -- We will apply the same technique to the left hand side factors.
  have h₃ : (p - 1) * (q - 1) * (r - 1) + 1 = (p - 1) * (q - 1) * r := by
    ring_nf
    nth_rw 2 [← mul_one (r - 1)]
    rw [← mul_add, ← mul_add]
    ring_nf

  have h₄ : (p - 1) * (q - 1) * r + 1 ∣ p * q * r := by
    rw [← h₃]
    exact h₂

  rw [show (p - 1) * (q - 1) * r + 1 = (p * q - 1) * r + 1 by nlinarith] at h₄
  rw [show (p - 1) * (q - 1) * (r - 1) + 1 = (p * q - 1) * (r - 1) + 1 by nlinarith] at h₂

  have hr' : r.Coprime (p * q) := by
    apply Coprime.mul_right
    · apply Coprime.symm
      apply (Coprime.mul_right_iff_left (by linarith)).mpr
      have : (p * q - 1) * r + 1 = p * q * r := by
        apply Int.eq_of_dvd_of_dvd
        · have : p * q * r = (p * q - 1) * r + 1 + (p * q - 1) * (r - 1) + 1 := by
            ring_nf
            rw [add_assoc]
            nth_rw 2 [← mul_one (r - 1)]
            rw [← mul_add, ← mul_add]
            ring_nf
          rw [this]
          apply Int.dvd_add
          · exact h₂
          apply Int.dvd_mul_right
        · apply Int.dvd_add
          · apply Int.dvd_mul_right
          exact h₄
      rw [this]
      apply Int.dvd_sub
      · ring
      exact h₄
    · have : p * q * r = (p * q - 1) * r + 1 + (p - 1) * (q - 1) * (r - 1) + 1 := by
        ring_nf
        nth_rw 2 [← mul_one (r - 1)]
        rw [← mul_add, ← mul_add]
        ring_nf
      rw [this]
      apply Int.dvd_add
      · exact h₄
      apply Int.dvd_mul_right

  have hs := Coprime.sq_add_one_mul_left.mp hr'
  have hpq : (p * q - 1).Coprime (p * q) := by
    apply Coprime.symm
    apply Coprime.mul_right
    · apply Coprime.symm
      apply Coprime.sub_one_left
      nlinarith
    · exact hp
  have h₅ : (p * q - 1) * (r - 1) + 1 ∣ p * q * r := by
    apply Int.dvd_add
    · exact h₂
    · apply Int.dvd_mul_right
  have h₆ : (p * q - 1) * (r - 1) + 1 = (p * q - 1) * (r - 1) + (p * q - 1) * 1 := by ring
  rw [h₆] at h₅
  have h₇ := Coprime.dvd_mul_left hpq h₅
  rw [show (p * q - 1) * (r - 1) + (p * q - 1) * 1 = (p * q - 1) * r by ring] at h₇

  -- From the above we have $(p * q - 1) * r \mid p * q * r$.
  -- But $r \mid r$ so we must have $(p * q - 1) \mid p * q$.
  have h₈ : (p * q - 1) ∣ p * q := by
    apply Int.dvd_of_mul_dvd_mul_right at h₇
    exact h₇
    exact hr

  apply Int.le_of_dvd at h₈
  have h₉ : 1 ≤ p * q - 1 := by
    apply one_le_sub_of_lt
    nlinarith
  rw [show p * q = p * q - 1 + 1 by omega] at h₈
  have h₁₀ : p * q - 1 ≤ p * q - 1 + 1 := by exact Int.le_add_right (p * q - 1) 1
  rw [← h₈] at h₁₀
  have h₁₁ : p * q - 1 = p * q - 1 + 1 - 1 := by omega
  rw [h₁₁] at h₁₀
  -- So we must have $(p * q - 1) = p * q - 1 + 1 - 1$.
  -- Which means $p * q - 1$ is of the form $p * q - 1 + 1 - 1$.
  -- So $p * q - 1$ is of the form $p * q - 1 + 1 - 1$.
  -- So $p * q - 1$ is of the form $p * q - 1 + 1 - 1$.
  have h₁₂ : (p * q - 1) % (p * q) = p * q - 1 := by
    apply mod_eq_of_dvd
    apply Int.dvd_add_right
    exact h₈
  apply congrArg (fun x ↦ 1 + x) at h₁₂
  have h₁₃ : (p * q - 1 + 1) % (p * q) = 0 := by
    rw [add_comm]
    rw [Int.add_sub_cancel]
    rw [Nat.add_one_mod_eq_zero_iff]
    suffices (p * q - 1) % (p * q) < p * q by exact Nat.mod_eq_zero_of_lt this
    rw [h₁₂]
    apply Nat.lt_mul_of_pos_right
    exact Nat.zero_lt_of_lt hp
  rw [show 1 + (p * q - 1) = p * q by ring] at h₁₃
  apply Nat.mod_eq_zero_iff_dvd at h₁₃
  have h₁₄ : (p * q - 1).natAbs ∣ (p * q).natAbs := by
    have : (p * q - 1).natAbs = p * q - 1 := by
      apply Int.natAbs_of_nonneg
      apply Int.sub_nonneg_of_le
      apply one_le_sub_one_of_lt
      linarith
    rw [this]
    apply dvd_trans h₈
    apply Int.natAbs_dvd_natAbs
  apply Nat.le_of_dvd at h₁₄
  have h₁₅ : 1 ≤ p * q - 1 := by
    apply one_le_sub_of_lt
    linarith
  have h₁₆ : (p * q - 1) % (p * q) < p * q := by
    apply Nat.mod_lt
    exact h₉
  rw [h₁₂] at h₁₆
  have h₁₇ : p * q - 1 < p * q := by exact Nat.sub_one_lt_self_iff.mpr Nat.zero_lt_of_lt h₉
  have h₁₈ : p * q ≤ p * q - 1 := by
    apply le_of_dvd (by exact Nat.zero_lt_of_lt h₉)
    exact h₁₄
  linarith

```