-- Notice that
  -- 4 ^ (3/2) = (2^2) ^ (3/2) = 2^3 = 8
  have : (4 : ℝ) ^ (3 / 2 : ℝ) = 8 := by
    calc
      (4 : ℝ) ^ (3 / 2 : ℝ) = ((2 ^ (2 : ℝ)) ^ (3 / 2 : ℝ)) := by norm_num
      _ = (2 ^ (2 : ℝ) ) ^ (3 / 2 : ℝ) := by rw [← Real.rpow_mul (by norm_num)]
      _ = 2 ^ (3 : ℝ) := by rw [← Real.rpow_mul (by norm_num)]
      _ = 8 := by norm_num

  -- hence we have
  -- 4 ^ (3/2) = 8 = 7 ^ d implies that d = 3/2
  have hd : d = (3 / 2 : ℝ) := by
    have : (7 : ℝ) ^ (d : ℝ) = (7 : ℝ) ^ (3 / 2 : ℝ) := by rw [h₄, this]
    have : d = (3 / 2 : ℝ) := by
      apply_fun (Real.logb 7) at this
      apply_fun (Real.logb 7) at this
      simp [Real.logb_rpow] at this
      assumption
    assumption

  -- We can use the same method to compute the other values.
  have hc : c = (3 / 2 : ℝ) := by
    have : (6 : ℝ) ^ (c : ℝ) = (6 : ℝ) ^ (3 / 2 : ℝ) := by rw [h₃, this]
    have : c = (3 / 2 : ℝ) := by
      apply_fun (Real.logb 6) at this
      apply_fun (Real.logb 6) at this
      simp [Real.logb_rpow] at this
      assumption
    assumption

  have hb : b = (3 / 2 : ℝ) := by
    have : (5 : ℝ) ^ (b : ℝ) = (5 : ℝ) ^ (3 / 2 : ℝ) := by rw [h₂, this]
    have : b = (3 / 2 : ℝ) := by
      apply_fun (Real.logb 5) at this
      apply_fun (Real.logb 5) at this
      simp [Real.logb_rpow] at this
      assumption
    assumption

  have ha : a = (3 / 2 : ℝ) := by
    have : (4 : ℝ) ^ (a : ℝ) = (4 : ℝ) ^ (3 / 2 : ℝ) := by rw [h₁, this]
    have : a = (3 / 2 : ℝ) := by
      apply_fun (Real.logb 4) at this
      apply_fun (Real.logb 4) at this
      simp [Real.logb_rpow] at this
      assumption
    assumption

  -- Then, we can compute the answer.
  rw [ha, hb, hc, hd]
  norm_num

```