obtain ⟨k, hk_pos, hk⟩ := h₁
  have h₂ : 0 < a * b := mul_pos h₀.1 h₀.2
  have h₃ : 0 < a * b ^ 2 := mul_pos h₀.1 (pow_pos h₀.2 2)
  have h₄ : 0 < a ^ 2 * b := mul_pos (pow_pos h₀.1 2) h₀.2
  have h₅ : 0 < a ^ 2 * b ^ 2 := mul_pos (pow_pos h₀.1 2) (pow_pos h₀.2 2)
  have h₆ : a + b ^ 2 > 0 := by nlinarith
  have h₇ : b + a ^ 2 > 0 := by nlinarith
  have h₈ : (a + b ^ 2) * (b + a ^ 2) > 0 := by nlinarith
  have h₉ : 2 ^ k > 0 := by positivity
  have h₁₀ : a = 1 := by
    -- We will use contradiction to show that a must be 1.
    by_contra! h
    -- If a ≠ 1, then a ≥ 2.
    have h₁₁ : a ≥ 2 := by
      have h₁₂ : a > 1 := by omega
      omega
    have h₁₂ : b ≥ 1 := by
      nlinarith
    have h₁₃ : (a + b ^ 2) * (b + a ^ 2) ≥ 2 * (b + a ^ 2) := by
      have h₁₄ : a + b ^ 2 ≥ 2 := by nlinarith
      nlinarith
    have h₁₄ : 2 ^ k < (a + b ^ 2) * (b + a ^ 2) := by
      have h₁₅ : 2 ^ k < 2 ^ (k + 1) := by
        apply Nat.pow_lt_pow_of_lt_right
        linarith
        linarith
      have h₁₆ : 2 ^ (k + 1) ≤ (a + b ^ 2) * (b + a ^ 2) := by
        have h₁₇ : (a + b ^ 2) * (b + a ^ 2) ≥ 2 ^ (k + 1) := by
          calc
            (a + b ^ 2) * (b + a ^ 2) ≥ 2 * (b + a ^ 2) := by nlinarith
            _ ≥ 2 ^ (k + 1) := by
              have h₁₈ : b + a ^ 2 ≥ 2 ^ k := by
                have h₁₉ : b + a ^ 2 ≥ 2 ^ k := by
                  have h₂₀ : b + a ^ 2 ≥ 2 ^ k := by
                    clear hk hk_pos h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₁ h₁₂ h₁₃
                    induction' k with k ih
                    · simp_all
                    · cases k with
                      | zero =>
                        simp_all
                        <;> nlinarith
                      | succ k =>
                        simp_all [Nat.pow_succ]
                        <;> nlinarith
                  exact h₂₀
                exact h₁₉
              calc
                2 * (b + a ^ 2) ≥ 2 * 2 ^ k := by nlinarith
                _ = 2 ^ (k + 1) := by ring
        exact h₁₇
      linarith
    nlinarith
  exact h₁₀