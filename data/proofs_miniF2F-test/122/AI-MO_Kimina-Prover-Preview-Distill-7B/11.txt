-- prove the Cauchy-Schwarz inequality
  have CS_ineq (a b c: ℝ) (h : 0 < a) (h' : 0 < b) (h'' : 0 < c): (a + b + c) ^ 2 ≤ 3 * (a ^ 2 + b ^ 2 + c ^ 2) := by
    have h₁ : 0 < a ^ 2 := pow_pos h 2
    have h₂ : 0 < b ^ 2 := pow_pos h' 2
    have h₃ : 0 < c ^ 2 := pow_pos h'' 2
    have h₄ : 0 < a * b := mul_pos h h'
    have h₅ : 0 < a * c := mul_pos h h''
    have h₆ : 0 < b * c := mul_pos h' h''

    -- 0 < (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + a * c + b * c) = a ^ 2 + b ^ 2 + c ^ 2 + (a + b) * (a + c) + (b + c) * (a + b) + (b + c) * (a + c)
    have h₇ : 0 < (a + b + c) ^ 2 := by
      apply pow_pos
      apply add_pos
      apply add_pos
      exact h₁
      exact h₂
      exact h₃

    -- break down the inequality into 3 parts, each part is positive and easy to prove
    suffices h : (a + b + c) ^ 2 / 3 ≤ a ^ 2 + b ^ 2 + c ^ 2 by
      have h' : 0 < (a + b + c) ^ 2 / 3 := by
        apply div_pos
        exact h₇
        norm_num
      have h'' : 0 < a ^ 2 + b ^ 2 + c ^ 2 := by
        apply add_pos
        apply add_pos
        exact h₁
        exact h₂
        exact h₃
      nlinarith
    apply div_le_iff₀
    · ring
    · nlinarith

  -- simplify the Cauchy-Schwarz inequality we get the expanded form
  replace CS_ineq (a b c: ℝ) (h : 0 < a) (h' : 0 < b) (h'' : 0 < c): a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + a * c + b * c) ≤ 3 * (a ^ 2 + b ^ 2 + c ^ 2) := by
    -- directly manipulate the expanded form of Cauchy-Schwarz inequality, eliminating the square terms to get a equivalent inequality
    -- whose expanded form is exactly the sum of squares of square roots of positive reals, thus each term is positive and easy to handle.
    have h₁ : 0 < a ^ 2 := pow_pos h 2
    have h₂ : 0 < b ^ 2 := pow_pos h' 2
    have h₃ : 0 < c ^ 2 := pow_pos h'' 2
    have h₄ : 0 < a * b := mul_pos h h'
    have h₅ : 0 < a * c := mul_pos h h''
    have h₆ : 0 < b * c := mul_pos h' h''
    have h₇ : a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + a * c + b * c)  = √(a ^ 2) ^ 2 + √(b ^ 2) ^ 2 + √(c ^ 2) ^ 2 + 2 * (√(a ^ 2) * √(b ^ 2) + √(a ^ 2) * √(c ^ 2) + √(b ^ 2) * √(c ^ 2)) := by
      simp only [pow_two]
      have h₇ : √(a ^ 2) ^ 2 = a ^ 2 := by
        refine Real.sq_sqrt?_
        linarith
      have h₈ : √(b ^ 2) ^ 2 = b ^ 2 := by
        refine Real.sq_sqrt?_
        linarith
      have h₉ : √(c ^ 2) ^ 2 = c ^ 2 := by
        refine Real.sq_sqrt?_
        linarith
      have h₁₀ : √(a * b) ^ 2 = a * b := by
        refine Real.sq_sqrt?_
        nlinarith
      have h₁₁ : √(a * c) ^ 2 = a * c := by
        refine Real.sq_sqrt?_
        nlinarith
      have h₁₂ : √(b * c) ^ 2 = b * c := by
        refine Real.sq_sqrt?_
        nlinarith
      ring_nf
      simp only [pow_two, √(a * b) ^ 2, √(a * c) ^ 2, √(b * c) ^ 2, h₇, h₈, h₉]
      linarith
    rw [h₇]
    apply CS_ineq
    · exact h
    · exact h'
    · exact h''

  -- directly manipulate the inequality, eliminate the square terms to get a equivalent inequality
  replace CS_ineq (a b c: ℝ) (h : 0 < a) (h' : 0 < b) (h'' : 0 < c): a + b + c ≤ √(3 * (a ^ 2 + b ^ 2 + c ^ 2)) := by
    -- exactly the expanded form of the inequality, since the coefficients are all positive, we can directly manipulate it
    have h₁ : 0 < a ^ 2 := pow_pos h 2
    have h₂ : 0 < b ^ 2 := pow_pos h' 2
    have h₃ : 0 < c ^ 2 := pow_pos h'' 2
    have h₄ : 0 < a * b := mul_pos h h'
    have h₅ : 0 < a * c := mul_pos h h''
    have h₆ : 0 < b * c := mul_pos h' h''
    suffices h : (a + b + c) ^ 2 ≤ 3 * (a ^ 2 + b ^ 2 + c ^ 2) by
      have h' : 0 < √(3 * (a ^ 2 + b ^ 2 + c ^ 2)) := by
        apply Real.sqrt_pos
        apply add_pos
        apply add_pos
        apply mul_pos
        norm_num
        exact h₁
        exact h₂
        exact h₃
      have h'' : 0 < a + b + c := by
        apply add_pos
        apply add_pos
        exact h
        exact h'
        exact h''
      apply (Real.sqrt_le_left?_).mpr
      · exact h
      · exact h'
    -- get the square root of positive reals, since the coefficients are all positive
    rw [←Real.sqrt_sq h', ←Real.sqrt_sq h'', ←Real.sqrt_sq h, Real.sqrt_sq]
    -- transform into product form for easier manipulation
    rw [←mul_assoc √3, ←Real.sqrt_mul (by norm_num)]
    nth_rw 2 [←Real.mul_self_sqrt (by norm_num)]
    -- directly manipulate, eliminate the square terms to get two inequalities, then apply the Cauchy-Schwarz inequality proved before
    rw [←mul_assoc, ←mul_assoc, mul_le_mul_iff_of_pos_left h₀]
    apply CS_ineq
    · apply add_pos
      apply add_pos
      exact h₁
      exact h₂
      exact h₃
    · apply mul_pos
      norm_num
      apply add_pos
      apply add_pos
      exact h₄
      exact h₅
      exact h₆

  -- get the reciprocals of square roots of positive reals, since the coefficients are all positive
  replace CS_ineq (a b c: ℝ) (h : 0 < a) (h' : 0 < b) (h'' : 0 < c): 1 / √a + 1 / √b + 1 / √c ≤ √(3 * (1 / a ^ 2 + 1 / b ^ 2 + 1 / c ^ 2)) := by
    -- directly apply the Cauchy-Schwarz inequality proved before
    have h₁ : 0 < 1 / a := (div_pos_iff_of_pos_right (by linarith)).mpr h
    have h₂ : 0 < 1 / b := (div_pos_iff_of_pos_right (by linarith)).mpr h'
    have h₃ : 0 < 1 / c := (div_pos_iff_of_pos_right (by linarith)).mpr h''
    have h₄ : 0 < 1 / (a ^ 2) := (div_pos_iff_of_pos_right (by linarith)).mpr h
    have h₅ : 0 < 1 / (b ^ 2) := (div_pos_iff_of_pos_right (by linarith)).mpr h'
    have h₆ : 0 < 1 / (c ^ 2) := (div_pos_iff_of_pos_right (by linarith)).mpr h''

    rw [←one_div_div, ←one_div_div, ←one_div_div]
    apply CS_ineq
    · apply add_pos
      apply add_pos
      exact h₁
      exact h₂
      exact h₃
    · apply mul_pos
      norm_num
      apply add_pos
      apply add_pos
      exact h₄
      exact h₅
      exact h₆

  -- transform the inequality into the form of harmonic mean inequality
  replace CS_ineq (a b c: ℝ) (h : 0 < a) (h' : 0 < b) (h'' : 0 < c): 1 / (1 / (1 / a + 1 / b + 1 / c)) ≤ 1 / (1 / √a + 1 / √b + 1 / √c) := by
    -- directly manipulate the inequality into an equivalent form
    have h₁ : 0 < 1 / (1 / a + 1 / b + 1 / c) := (one_div_pos_iff).mpr (by linarith)
    have h₂ : 0 < 1 / (1 / √a + 1 / √b + 1 / √c) := (one_div_pos_iff).mpr (by linarith)
    suffices h : (1 / √a + 1 / √b + 1 / √c) ≤ √(3 * (1 / a ^ 2 + 1 / b ^ 2 + 1 / c ^ 2)) by
      apply (Real.le_sqrt h₁ h₂).mp
      exact h
    -- get the reciprocal of square roots of positive reals, since the coefficients are all positive
    apply CS_ineq
    · apply one_div_pos.mpr
      exact h
    · apply one_div_pos.mpr
      exact h'
    · apply one_div_pos.mpr
      exact h''

  -- directly manipulate the inequality into the form required
  suffices h : (1 / (1 / (1 / a + 1 / b + 1 / c))) ^ 2 ≤ 9 / (a + b + z) by
    have h' : 0 < 1 / (1 / (1 / a + 1 / b + 1 / c)) := (one_div_pos_iff).mpr (by linarith)
    have h'' : 0 < 1 / (1 / √a + 1 / √b + 1 / √c) := (one_div_pos_iff).mpr (by linarith)
    apply (Real.sqrt_le_sqrt_iff_of_pos h' h'').mpr
    simp only [pow_two]
    field_simp
    apply le_of_le_of_eq
    -- directly apply the harmonic mean inequality proved before
    apply CS_ineq
    · apply one_div_pos.mpr
      exact h
    · apply one_div_pos.mpr
      exact h'
    · apply one_div_pos.mpr
      exact h''

  -- get the reciprocals of square roots of positive reals, since the coefficients are all positive
  replace h : a + b + z ≤ √(9 * (a ^ 2 + b ^ 2 + z ^ 2)) := by
    -- exactly the expanded form of the inequality, since the coefficients are all positive
    have h₁ : 0 < a ^ 2 := pow_pos h 2
    have h₂ : 0 < b ^ 2 := pow_pos h' 2
    have h₃ : 0 < z ^ 2 := pow_pos h'' 2
    have h₄ : 0 < a * b := mul_pos h h'
    have h₅ : 0 < a * z := mul_pos h h''
    have h₆ : 0 < b * z := mul_pos h' h''

    suffices h : (a + b + z) ^ 2 ≤ 3 * (3 * (a ^ 2 + b ^ 2 + z ^ 2)) by
      apply (Real.sqrt_le_sqrt_iff_of_pos (by linarith) (by linarith)).mp
      linarith
    -- transform into product form for easier manipulation
    rw [←mul_assoc, ←mul_assoc, mul_le_mul_iff_of_pos_left (by linarith)]
    -- directly manipulate the inequality into an equivalent form
    rw [add_assoc, add_assoc, <-mul_add]
    have h₇ : 3 * (a ^ 2 + b ^ 2 + z ^ 2) = a * (2 * a) + b * (2 * b) + z * (2 * z) := by ring
    rw [h₇]
    -- directly apply the Cauchy-Schwarz inequality proved before
    apply CS_ineq
    · apply add_pos
      apply add_pos
      exact h₁
      exact h₂
      exact h₃
    · apply mul_pos
      norm_num
      apply add_pos
      apply add_pos
      exact h₄
      exact h₅
      exact h₆

  -- apply the inequality to reciprocals, since the coefficients are all positive
  replace h : 1 / (a + b + z) ≤ 1 / √(9 * (a ^ 2 + b ^ 2 + z ^ 2)) := by
    apply one_div_le_one_div_of_le
    · linarith
    · apply one_div_le_one_div_of_le
      · norm_num
      · apply mul_le_mul_of_nonneg_left
        · exact h
        · norm_num
      · linarith
  apply one_div_le_one_div_of_le
  apply h
  apply one_div_pos
  apply add_pos
  apply add_pos
  · apply mul_pos
    norm_num
    exact h
  · apply mul_pos
    norm_num
    exact h'
  · apply mul_pos
    norm_num
    exact h''

```