-- the key inequality
  have key (n : ℕ) : ∑ k in Finset.Icc (n + 1) 4 * n, 1 / Real.sqrt k
      ≤ 2 * n / Real.sqrt (n + 1) := by
    have h0 : 2 * n / Real.sqrt (n + 1) = ∑ k in Finset.Icc (n + 1) (n + 1), 2 * Real.sqrt (1 / (4 * n)) / Real.sqrt (n + 1) := by
      simp only [Finset.sum_Icc_succ_top, Finset.sum_singleton]
      field_simp
      ring
    rw [h0]
    apply Finset.sum_le_sum
    intro i hi
    simp only [Finset.mem_Icc] at hi
    rw [← Finset.sum_const]
    apply le_of_eq
    rw [Finset.sum_const]
    let g (x : ℕ) : ℝ := 1 / (4 * x)
    have hg : StrictAnti g := by
      intro a b h
      simp only [g] at h
      simp only [Set.mem_Ioi]
      apply Real.lt_sqrt_of_sq_lt
      simp only [pow_two, mul_comm]
      rw [div_lt_div_iff₀]
      simp
      linarith
      simp
      apply Nat.one_le_of_lt
      apply Nat.lt_of_succ_lt
      exact h
      exact h
    have hg' : Monotone g := by
      intro a b h
      simp only [g] at h
      simp only [Set.mem_Ioi]
      apply Real.lt_sqrt_of_sq_lt
      simp only [pow_two, mul_comm]
      rw [div_lt_div_iff₀]
      simp
      linarith
      simp
      apply Nat.one_le_of_lt
      apply Nat.lt_of_succ_lt
      exact h
      exact h
    rw [← Finset.range_comp_g]
    have : Finset.range 3 * n = Finset.range (3 * n) := by
      refine Finset.range_eq_of_ne_zero?_
      exact Nat.ne_zero_iff_zero_lt.mpr h
    rw [this]
    apply Finset.sum_range_succ
    apply Finset.sum_range_succ
    apply Finset.sum_range_succ
    simp only [g]
    simp
    rw [div_le_div_iff₀]
    have : 4 * (n + 1) ≤ 4 * n := by
      apply Nat.mul_le_mul_right
      apply Nat.succ_le_of_lt
      exact h
    apply le_trans this
    apply le_of_eq
    ring
    apply Nat.one_le_of_lt
    exact h
    exact h
  -- divide the sum into union of sums
  have h1 : ∑ k ∈ Finset.Icc 2 10000, 1 / Real.sqrt k = ∑ k ∈ Finset.Icc 2 10000, 1 / Real.sqrt k := by
    rfl
  change ∑ k ∈ Finset.Icc 2 10000, 1 / Real.sqrt k < 198
  -- notice that 10000 = 4 x 2500
  rw [show 10000 = 4 * 2500 by norm_num]
  have h2 : ∑ k ∈ Finset.Icc 2 10000, 1 / Real.sqrt k ≤ ∑ k ∈ Finset.Icc 2 10000, 1 / Real.sqrt k := by
    exact le_rfl
  -- use the key inequality to get some inequalities
  have m1 := key 0
  have m2 := key 2500
  have m3 := key 1
  have m4 := key 3
  -- rw [h1] at m2
  rw [show 2500 + 1 = 2501 by norm_num] at m2
  rw [show 4 * 2500 = 10000 by norm_num] at m2
  have g1 := Finset.sum_nonneg (fun i : ℕ => (1 / 1 : ℝ))
  -- turn the inequality into a useful form
  simp only [Finset.sum_const] at g1
  have g2 : (Finset.card (Finset.Icc 2 10000)) = 9999 := by
    simp
  rw [g2] at g1 m1 m2 m3 m4
  -- estimate the sum
  have : 9999 ≤ ∑ k ∈ Finset.Icc 2 10000, 2 * Real.sqrt (1 / (4 * k)) := by
    apply g1.trans
    rw [Finset.mul_sum]
    apply Finset.sum_le_sum
    simp only [Finset.mem_Icc]
    intro a ha
    rw [mul_comm]
    apply mul_le_mul
    exact zero_le_two
    exact le_refl (Real.sqrt (1 / (4 * a)))
    exact Real.sqrt_nonneg (1 / (4 * a))
    apply le_of_lt
    apply lt_trans (Real.sqrt_lt_sqrt (by norm_num) (by norm_num))
    apply lt_of_lt_of_le?_ m2
    norm_num
    norm_num
    apply Finset.card_Icc
    exact Nat.le_mul_self a
  -- the last inequality
  have : ∑ k ∈ Finset.Icc 2 10000, 2 * Real.sqrt (1 / (4 * k)) ≤ 9999 * 2 * Real.sqrt (1 / (4 * 2)) := by
    apply Finset.sum_le_sum
    simp only [Finset.mem_Icc]
    intro a ha
    apply le_of_lt
    apply lt_trans (Real.sqrt_lt_sqrt (by norm_num) (by norm_num))
    apply lt_of_lt_of_le?_ m1
    simp
    exact a
  rw [h1] at this
  have : 9999 * 2 * Real.sqrt (1 / (4 * 2)) = 9999 * 2 * (1 / 2) := by
    congr
    exact rfl
  rw [this]
  simp only [mul_div_cancel₀]
  linarith
```