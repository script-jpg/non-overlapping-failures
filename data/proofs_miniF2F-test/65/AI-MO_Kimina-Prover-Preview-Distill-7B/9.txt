-- The basic idea is that we can bash this algebraically, and it reduces to 2.
  calc
    Real.log 80 / Real.log 2 / (Real.log 2 / Real.log 40) -
        Real.log 160 / Real.log 2 / (Real.log 2 / Real.log 20)
      = (Real.log 80 * Real.log 40 - Real.log 160 * Real.log 20) / (Real.log 2 ^ 2) := by
        field_simp
        ring
    _ = (Real.log 16 * Real.log 20 - Real.log 160 * Real.log 20) / (Real.log 2 ^ 2) := by
        rw [show Real.log 80 = Real.log 16 * Real.log 2 / Real.log 40 by rw [←Real.log_div_log_eq_log_div] <;> norm_num]
        rw [show Real.log 40 = Real.log 20 * Real.log 2 by rw [←Real.log_div_log_eq_log_div] <;> norm_num]
        field_simp
        ring
    _ = ((Real.log 16 - Real.log 160) * Real.log 20) / (Real.log 2 ^ 2) := by
        field_simp
        ring
    _ = ((Real.log 2 ^ 4 - Real.log 2 ^ 2 - Real.log 2 ^ 5) * Real.log 20) / (Real.log 2 ^ 2) := by
        have log_160 : Real.log 160 = 5 * Real.log 2 + Real.log 2 := by
          rw [show (160 : ℝ) = 16 * 10 by norm_num]
          rw [Real.log_mul (by norm_num) (by norm_num)]
          rw [show (16 : ℝ) = 2 ^ 4 by norm_num]
          rw [Real.log_pow]
          ring
        have log_20 : Real.log 20 = 2 * Real.log 2 + Real.log 2 := by
          rw [show (20 : ℝ) = 2 ^ 2 * 5 by norm_num]
          rw [Real.log_mul (by norm_num) (by norm_num)]
          rw [Real.log_pow]
          ring
        rw [log_160, log_20]
        field_simp
        ring
    _ = ((Real.log 2 ^ 4 - Real.log 2 ^ 2 - Real.log 2 ^ 5) * (2 * Real.log 2 + Real.log 2)) / (Real.log 2 ^ 2) := by
        rw [show (20 : ℝ) = 2 ^ 2 * 5 by norm_num]
        rw [Real.log_mul (by norm_num) (by norm_num)]
        rw [Real.log_pow]
        ring
    _ = 2 := by
        field_simp
        ring
```