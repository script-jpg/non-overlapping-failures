-- Boring lemma that I'm too too too late to prove
  have l_0 (x y : ℝ) : (x - y) ^ 2 ≥ 0 := by exact sq_nonneg (x - y)
  -- Boring lemma that I'm too too too late to prove
  have l_1 (x y : ℝ) : x - y ≤ abs (x - y) := by exact sub_le_abs (x - y)
  -- Boring lemma that I'm too too too late to prove
  have l_2 (x y : ℝ) : abs (x - y) ≤ x + y := by
    have : abs (x - y) ≤ abs x + abs y := abs_sub x y
    suffices h : abs x ≤ x ∧ abs y ≤ y by linarith
    exact ⟨abs_le.mp h.1, abs_le.mp h.2⟩

  -- let $b=2^{1+⌊\lfloor\log_{1/2} a\rfloor+1⌋}$
  set b := 2 ^ (1 + ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) with hb
  have hb_pos : 0 < b := by positivity
  -- Is it possible that $f(x)$ has a minimum value of $0$ at some point? 
  have h₂ : ∀ x, 0 ≤ f x ∧ f x ≤ 1 := by
    intro x
    induction x using Int.induction_on with
    | hz =>
      simp
      specialize h₁ 0
      simp at h₁
      have : 0 < f 0 := by
        have := h₁.symm.trans (by simp)
        linarith
      constructor <;> linarith
    | hp x hx =>
      intro hx'
      rw [h₁]
      nth_rewrite 2 [hx]
      rw [hb]
      simp
      calc _
      _ ≤ 1 / 2 + √((1 : ℝ) - 0) := by
        apply add_le_add
       . rw [Real.rpow_le_rpow_iff (by norm_num)]
          suffices h : (1 : ℝ) ≤ (2 : ℝ) ^ (1 + ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) by norm_num; exact h
          apply Real.one_le_rpow
          norm_num
          simp at hb
          rw [Real.logb_rpow (by norm_num) (by norm_num)]
          have : ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ ≥ 0 := by
            have : ⌊logb (1 / 2) a⌋ ≥ -1 := by
              rw [Int.floor_le_iff]
              have : logb (1 / 2) a < 0 := by
                rw [logb_neg_iff]
                left
                simp_all
                linarith
              constructor
              any_goals linarith
            rw [Int.floor_add_one_le_iff]
            omega
          apply Int.floor_nonneg
          simp_all
       . apply add_le_add
         . apply Real.sqrt_le_sqrt
            linarith
         . linarith
      _ ≤ 1 := by
        rw [Real.rpow_le_one_iff]
        norm_num
        simp
        rw [Real.logb_rpow (by norm_num) (by norm_num)]
        have : ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ ≥ 0 := by
          have : ⌊logb (1 / 2) a⌋ ≥ -1 := by
            rw [Int.floor_le_iff]
            have : logb (1 / 2) a < 0 := by
              rw [logb_neg_iff]
              left
              simp_all
              linarith
            constructor
            any_goals linarith
          rw [Int.floor_add_one_le_iff]
          omega
        have : (2 : ℝ) ^ (⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) ≥ 1 := by
          apply Real.one_le_rpow
          norm_num
          suffices h : (⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) ≥ 0 by exact h
          rw [Int.floor_add_one_le_iff]
          omega
        linarith
    | hn x hx =>
      intro hx'
      rw [h₁]
      rw [hb]
      simp
      have : 0 < f (x + a) := by
        have := h₁.symm.trans (by simp)
        linarith
      constructor
     . linarith
     . calc _
          _ ≤ 1 / 2 + √((1 : ℝ) - 1) := by
            apply add_le_add
           . rw [Real.rpow_le_rpow_iff (by norm_num)]
              suffices h : (1 : ℝ) ≤ (2 : ℝ) ^ (1 + ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) by norm_num; exact h
              apply Real.one_le_rpow
              norm_num
              simp at hb
              rw [Real.logb_rpow (by norm_num) (by norm_num)]
              have : ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ ≥ 0 := by
                have : ⌊logb (1 / 2) a⌋ ≥ -1 := by
                  rw [Int.floor_le_iff]
                  have : logb (1 / 2) a < 0 := by
                    rw [logb_neg_iff]
                    left
                    simp_all
                    linarith
                  constructor
                  any_goals linarith
                rw [Int.floor_add_one_le_iff]
                omega
              apply Int.floor_nonneg
              simp_all
           . apply Real.sqrt_le_sqrt
              linarith
          _ ≤ 1 := by
            rw [Real.rpow_le_one_iff]
            norm_num
            simp
            rw [Real.logb_rpow (by norm_num) (by norm_num)]
            have : ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ ≥ 0 := by
              have : ⌊logb (1 / 2) a⌋ ≥ -1 := by
                rw [Int.floor_le_iff]
                have : logb (1 / 2) a < 0 := by
                  rw [logb_neg_iff]
                  left
                  simp_all
                  linarith
                constructor
                any_goals linarith
              rw [Int.floor_add_one_le_iff]
              omega
            have : (2 : ℝ) ^ (⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) ≥ 1 := by
              apply Real.one_le_rpow
              norm_num
              suffices h : (⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) ≥ 0 by exact h
              rw [Int.floor_add_one_le_iff]
              omega
            linarith

  -- We conjecture that $f(x)$ is strictly increasing. Intuitively, this must be the case, but I don't have a proof.
  have h₃ : StrictMonoOn f (Set.univ := Set.univ) := by
    intro x y hxy
    specialize h₁ x
    specialize h₁ y
    have : f (x + a) > f (y + a) := by
      apply lt_of_le_of_ne
     . simpa using h₁.trans (StrictMonoOn.le_iff.mp hxy)
     . by_contra h
        have : f x = f y := by linarith
        simp [← h] at h₁
        linarith
    specialize h₁ y
    linarith

  -- Let $b=2^{1+⌊\lfloor\log_{1/2} a\rfloor+1⌋}$. 
  -- By the definition, $a=\left(\frac{1}{2}\right)^{-\lfloor\lfloor\log_{1/2} a\rfloor+1⌋}$
  have h₄ : a = (1 / 2) ^ (- ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ : ℝ) := by
    rw [Real.rpow_neg (by norm_num), ← Real.rpow_mul (by norm_num)]
    rw [logb_rpow (by norm_num) (by norm_num)]
    have : ⌊(⌊logb (1 / 2) a⌋ : ℝ) + 1⌋ ≥ 0 := by
      have : ⌊logb (1 / 2) a⌋ ≥ -1 := by
        rw [Int.floor_le_iff]
        have : logb (1 / 2) a < 0 := by
          rw [logb_neg_iff]
          left
          simp_all
          linarith
        constructor
        any_goals linarith
      rw [Int.floor_add_one_le_iff]
      omega
    norm_cast
    simp_all

  -- Since $f(x+2a)=f(x+a)$, we have $f(x+b)=f(x)$ for all $x$.
  use b
  refine ⟨hb_pos,?_⟩
  intro x
  calc _
  -- The first equality is due to the fact that $f(x+2a)=f(x+a)$
  _ = f (x + 2 * a) := by
    ring_nf
    specialize h₃ (x + a) (x + 2 * a) (by linarith)
    linarith
  -- The second equality is due to the fact that $f(x+a)=1/2+\sqrt{f(x)-f(x)^2}$
  _ = f (x + a + a) := by
    congr 1
    ring
  _ = 1 / 2 + Real.sqrt (f (x + a) - f (x + a) ^ 2) := by
    rw [h₁]
  -- The goal is now to show that $1/2+\sqrt{f(x+a)-f(x+a)^2}=f(x)$
  -- We first showed that $0\leq f(x+a)-f(x+a)^2\leq 1$, so the square root is well-defined
  have h₅ : 0 ≤ f (x + a) - f (x + a) ^ 2 ∧ f (x + a) - f (x + a) ^ 2 ≤ 1 := by
    rw [sub_nonneg]
    constructor
   . specialize h₂ (x + a) (x + a)
      linarith
   . specialize h₂ (x + a) (x + a)
      linarith
  -- We then showed that $f(x+a)-f(x+a)^2\leq 1/4$
  have h₆ : f (x + a) - f (x + a) ^ 2 ≤ 1 / 4 := by
    have h₆ : (f (x + a) - 1 / 2) ^ 2 ≥ 0 := by
      apply sq_nonneg
    linarith
  -- We showed that $1/2+\sqrt{f(x+a)-f(x+a)^2}=f(x)$
  calc _
  _ = 1 / 2 + √(f (x + a) - f (x + a) ^ 2) + (f (x + a) - 1 / 2) - (f (x + a) - 1 / 2) := by
    ring_nf
    rw [sub_add_cancel]
    ring
  _ = 1 / 2 + √(f (x + a) - f (x + a) ^ 2) + (-(f (x + a)) + 1 / 2) + (f (x + a) - 1 / 2) := by
    ring
  _ = 1 / 2 + √(f (x + a) - f (x + a) ^ 2) + (-(f (x + a)) + 1 / 2 + f (x + a) - 1 / 2) := by
    ring
  _ = 1 / 2 + √(f (x + a) - f (x + a) ^ 2) + 0 := by
    ring
  _ = 1 / 2 + √(f (x + a) - f (x + a) ^ 2) := by
    ring
  -- The fourth equality is due to the fact that $f(x+a)=1/2+\sqrt{f(x)-f(x)^2}$, which implies $-(f(x+a))+1/2=f(x)-f(x)^2$
  _ = f x := by
    specialize h₁
    linarith

```