-- Let `a n` be the product `∏ k ∈ [1, n], (1 + 1/k^3)`.

  let a : ℕ → ℝ := fun n => (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3)

  -- Let `b n` be the product `∏ k ∈ [1, n], (1 + 1/k^2)`.
  let b : ℕ → ℝ := fun n => (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 2)

  -- Let `c n` be the sum `∑ k ∈ [1, n], 1/k^3`.
  let c : ℕ → ℝ := fun n => (∑ k in Finset.Icc 1 n, 1 / (k : ℝ) ^ 3)

  -- Let `p n` be the sum `∑ k ∈ [1, n], 1/k^2`.
  let p : ℕ → ℝ := fun n => (∑ k in Finset.Icc 1 n, 1 / (k : ℝ) ^ 2)

  -- Let `q n` be the sum `∑ k ∈ [1, n], 1/k^3`.
  let q : ℕ → ℝ := fun n => (∑ k in Finset.Icc 1 n, 1 / (k : ℝ) ^ 3)

  -- Obviously, we have `a n > 0` and `b n > 0` and `c n > 0` and `p n > 0` and `q n > 0` for all `n > 0`.

  have an_pos : ∀ n > 0, a n > 0 := by
    intro n hn
    apply Finset.prod_pos
    simp [a]
    exact hn

  have bn_pos : ∀ n > 0, b n > 0 := by
    intro n hn
    apply Finset.prod_pos
    simp [b]
    exact hn

  have cn_pos : ∀ n > 0, c n > 0 := by
    intro n hn
    apply Finset.sum_pos
    simp [c]
    exact hn

  have pn_pos : ∀ n > 0, p n > 0 := by
    intro n hn
    apply Finset.sum_pos
    simp [p]
    exact hn

  have qn_pos : ∀ n > 0, q n > 0 := by
    intro n hn
    apply Finset.sum_pos
    simp [q]
    exact hn

  -- We can show that `a (n + 1) = a n * (1 + 1 / (n + 1)^3)`, `b (n + 1) = b n * (1 + 1 / (n + 1)^2)`,
  -- `c (n + 1) = c n + 1 / (n + 1)^3`, `p (n + 1) = p n + 1 / (n + 1)^2`, and
  -- `q (n + 1) = q n + 1 / (n + 1)^3`.

  have a Recursion dif
  have b Recursion dif
  have c Recursion dif
  have p Recursion dif
  have q Recursion dif

  have a_next : ∀ n > 0, a (n + 1) = a n * (1 + 1 / (n + 1) ^ 3) := by
    intro n hn
    calc
      _ = (∏ k ∈ Finset.Icc 1 (n + 1), 1 + 1 / k ^ 3) := rfl
      _ = (∏ k ∈ Finset.Icc 1 n, 1 + 1 / k ^ 3) * (1 + 1 / (n + 1) ^ 3) := by
        rw [Finset.prod_Icc_succ_top, add_assoc]
        simp
      _ = _ := rfl

  have b_next : ∀ n > 0, b (n + 1) = b n * (1 + 1 / (n + 1) ^ 2) := by
    intro n hn
    calc
      _ = (∏ k ∈ Finset.Icc 1 (n + 1), 1 + 1 / k ^ 2) := rfl
      _ = (∏ k ∈ Finset.Icc 1 n, 1 + 1 / k ^ 2) * (1 + 1 / (n + 1) ^ 2) := by
        rw [Finset.prod_Icc_succ_top, add_assoc]
        simp
      _ = _ := rfl

  have c_next : ∀ n > 0, c (n + 1) = c n + 1 / (n + 1) ^ 3 := by
    intro n hn
    calc
      _ = (∑ k ∈ Finset.Icc 1 (n + 1), 1 / k ^ 3) := rfl
      _ = (∑ k ∈ Finset.Icc 1 n, 1 / k ^ 3) + 1 / (n + 1) ^ 3 := by
        rw [Finset.sum_Icc_succ_top]
        simp
      _ = _ := rfl

  have p_next : ∀ n > 0, p (n + 1) = p n + 1 / (n + 1) ^ 2 := by
    intro n hn
    calc
      _ = (∑ k ∈ Finset.Icc 1 (n + 1), 1 / k ^ 2) := rfl
      _ = (∑ k ∈ Finset.Icc 1 n, 1 / k ^ 2) + 1 / (n + 1) ^ 2 := by
        rw [Finset.sum_Icc_succ_top]
        simp
      _ = _ := rfl

  have q_next : ∀ n > 0, q (n + 1) = q n + 1 / (n + 1) ^ 3 := by
    intro n hn
    calc
      _ = (∑ k ∈ Finset.Icc 1 (n + 1), 1 / k ^ 3) := rfl
      _ = (∑ k ∈ Finset.Icc 1 n, 1 / k ^ 3) + 1 / (n + 1) ^ 3 := by
        rw [Finset.sum_Icc_succ_top]
        simp
      _ = _ := rfl

  -- We can also show that `a n ≤ b n` for all `n > 0`.

  have an_le_bn : ∀ n > 0, a n ≤ b n := by
    intro n hn
    calc
      _ = (∏ k ∈ Finset.Icc 1 n, 1 + 1 / k ^ 3) := rfl
      _ ≤ (∏ k ∈ Finset.Icc 1 n, 1 + 1 / k ^ 2) := by
        apply Finset.prod_le_prod
        simp [hn]
        intro k hk
        rw [le_div_iff₀]
        calc
          _ ≤ 1 + 1 / k ^ 3 := by norm_num
          _ ≤ 1 + 1 / k ^ 2 := by
            have : 1 / k ^ 3 ≤ 1 / k ^ 2 := by
              apply one_div_le_one_div
              norm_num
              calc
                _ = k * k := by ring
                _ ≤ k * k + 1 := by norm_num
                _ = k ^ 2 + 1 := by ring
            linarith
        simp [hk]
      _ = _ := rfl

  -- Base case: `a 1 = 1 + 1 / 1^3 = 2` and `b 1 = 1 + 1 / 1^2 = 2`, so `a 1 = b 1`.

  have base : a 1 = b 1 := by
    simp [a, b]
    norm_num

  -- Inductive step: assume that `a n = b n` for some `n > 0`.

  have ind : ∀ n > 0, a n = b n → a (n + 1) = b (n + 1) := by
    intro n hn h
    rw [a_next n hn, b_next n hn, h]

  -- Now we have `a n = b n` for all `n > 0` by the induction principle.

  have an_eq_bn : ∀ n > 0, a n = b n := by
    intro n hn
    induction n with
    | zero => linarith
    | succ n ih => exact ind n ih

  -- Let's show that `b n ≤ 3 - 1 / n` for all `n > 0`.

  have bn_le_3m1_onn : ∀ n > 0, b n ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    -- We have `b n = (1 + 1/1^2) * (1 + 1/2^2) *... * (1 + 1/n^2)`.
    -- To prove that `b n ≤ 3 - 1/n`, it suffices to show that
    -- `(1 + 1/1^2) * (1 + 1/2^2) *... * (1 + 1/n^2) ≤ 3 - 1/n`.
    -- Taking logarithm on both sides, it suffices to show that
    -- `∑ k ∈ [1, n], 1/k^2 ≤ ln (3 - 1/n)`.
    -- Because `1/k^2 ≤ 1/(k-1) - 1/k` for `k ≥ 2`, we have
    -- `∑ k ∈ [2, n], 1/k^2 ≤ ∑ k ∈ [2, n], 1/(k-1) - 1/k = 1 - 1/n`.
    -- Hence `∑ k ∈ [1, n], 1/k^2 ≤ 1 + 1 - 1/n = 2 - 1/n`.
    -- And `2 - 1/n ≤ 3 - 1/n` since `1 ≤ 2 - 1/n` for `n ≥ 1`.
    induction' n, hn using Nat.le_induction with n hn ih
    · simp
    · calc
        _ = b n * (1 + 1 / (n + 1) ^ 2) := by rw [b_next n hn]
        _ ≤ (3 - 1 / ↑n) * (1 + 1 / (n + 1) ^ 2) := by
          apply mul_le_mul
          exact ih
          norm_num
          · apply add_pos
            · apply one_div_pos
              calc
                _ ≤ 3 := by norm_num
                _ < 3 - 1 / (n + 1) ^ 2 := by
                  suffices 1 < (n + 1) ^ 2 by
                    rw [pow_two] at this
                    simp at this
                    rw [this]
                    norm_num
                  calc
                    _ ≤ n + 1 := by
                      apply Nat.le_add_one
                    _ ≤ n + 1 + 1 := by
                      apply Nat.le_add_right
                    _ = (n + 1) + 1 := by ring
          · apply one_div_nonneg
            norm_num
        _ = 3 * (1 + 1 / (n + 1) ^ 2) - 1 / ↑n * (1 + 1 / (n + 1) ^ 2) := by
          ring
        _ ≤ 3 * (1 + 1 / (n + 1) ^ 2) := by
          apply sub_le_self
          apply mul_nonneg
          · apply one_div_nonneg
            norm_num
          · norm_num

  -- Now we have `a n ≤ b n ≤ 3 - 1/n` for all `n > 0` by the above.

  intro n hn
  -- Inductive step: assume that `a n ≤ 3 - 1/n` for some `n > 0`.

  induction n with
  | zero => linarith
  | succ n ih =>
    calc
      _ = a n * (1 + 1 / (n + 1) ^ 3) := by rw [a_next n hn]
      _ ≤ b n * (1 + 1 / (n + 1) ^ 3) := by
        apply mul_le_mul
        exact an_eq_bn n hn
        · norm_num
        · norm_num
        · apply add_pos
          · apply one_div_pos
            norm_num
          · apply one_div_pos
            norm_num
      _ ≤ (3 - 1 / ↑n) * (1 + 1 / (n + 1) ^ 3) := by
        apply mul_le_mul
        exact bn_le_3m1_onn n hn
        · norm_num
        · norm_num
        · apply add_pos
          · apply one_div_pos
            norm_num
          · apply one_div_pos
            norm_num
      _ ≤ 3 - 1 / (n + 1) := by
        apply sub_le_self
        apply mul_nonneg
        · apply one_div_nonneg
          norm_num
        · norm_num


```