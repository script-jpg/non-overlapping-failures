-- Let $n$ be a positive integer.
  -- We want to show that $\prod_{k=1}^n (1 + 1/k^3) \leq 3 - 1/n$.

  -- We use induction on $n$.
  induction n with
  | zero =>
    -- $n = 0$ case does not apply as $n > 0$.
    cases h₀
  | succ n ih =>
    -- $n = 0$ case does not apply as $n > 0$.
    cases h₀
    · -- Base case: $n = 1$
      norm_num
    · -- Inductive step: $n > 1$
      rw [Finset.prod_Icc_succ_top (by linarith only [h₀]) (by linarith only [h₀])]
      rw [show (↑(n + 1) : ℝ) = (↑n : ℝ) + 1 by norm_cast]
      -- We need to show that
      -- $\prod_{k=1}^n (1 + 1/k^3) \cdot (1 + 1/(n+1)^3) \leq 3 - 1/n - 1/(n+1)^3$.
      -- By the induction hypothesis, we have
      -- $\prod_{k=1}^n (1 + 1/k^3) \leq 3 - 1/n$.
      -- It suffices to show that
      -- $(3 - 1/n) \cdot (1 + 1/(n+1)^3) \leq 3 - 1/n - 1/(n+1)^3$.
      -- This can be done by a direct calculation.
      obtain ⟨ih1, ih2⟩ := ih
      ·
        calc
          $(∏ k ∈ Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) * (1 + 1 / ↑(n + 1) ^ 3) = (∏ k ∈ Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) * (1 + 1 / (↑n + 1) ^ 3) := by norm_cast; rw [Finset.prod_Icc_succ_top (by linarith only [h₀]) (by linarith only [h₀])]
          _ ≤ (3 - 1 / ↑n) * (1 + 1 / (↑n + 1) ^ 3) := by
            rw [mul_le_mul_right]
            · exact ih1
            positivity
          _ ≤ (3 : ℝ) - 1 / ↑n - 1 / (↑n + 1) ^ 3 := by
            norm_cast
            rw [sub_div, sub_div, ← pow_two, ← pow_two]
            have : (↑n : ℝ) * ((↑n + 1) ^ 2 + (↑n + 1) + 1) ≤ (↑n + 1) ^ 3 * 3 := by
              rw [show (3 : ℝ) = 3 * 1 by norm_num]
              apply mul_le_mul
              · simp
              · rw [← sub_nonneg]
                calc
                  $1 - ((↑n : ℝ) * (↑n + 1) * 2 + 1) ≤ 0 := by
                    apply sub_nonpos.mpr
                    apply le_of_lt
                    apply lt_of_le_of_lt (mul_le_mul_right (by simp) (by simp) (by simp)) (by simp)
                  _ = $1 - (↑n * 2 + 1) * ↑n * (↑n + 1) := by ring
                  _ ≤ 0 := by
                    apply sub_nonpos.mpr
                    ring_nf
                    rw [show (3 : ℝ) * (↑n + 1) ^ 3 = (↑n + 1) * (↑n + 1) * (↑n + 1) * 3 by ring]
                    apply mul_le_mul
                    · rw [mul_le_mul_right (by simp) (by simp)]
                      apply mul_le_mul (by simp) (by simp) (by simp) (by simp)
                    · norm_num
            calc
              $(3 - 1 / ↑n) - 1 / (↑n + 1) ^ 3 = 3 * (↑n + 1) ^ 3 / ↑n - 1 / (↑n + 1) ^ 3 := by
                rw [sub_div, sub_div, ← pow_two, ← pow_two]
                have : (↑n : ℝ) * ((↑n + 1) ^ 2 + (↑n + 1) + 1) ≤ (↑n + 1) ^ 3 * 3 := by
                  rw [show (3 : ℝ) = 3 * 1 by norm_num]
                  apply mul_le_mul
                  · simp
                  · rw [← sub_nonneg]
                    calc
                        $1 - ((↑n : ℝ) * (↑n + 1) * 2 + 1) ≤ 0 := by
                          apply sub_nonpos.mpr
                          apply le_of_lt
                          apply lt_of_le_of_lt (mul_le_mul_right (by simp) (by simp) (by simp)) (by simp)
                        _ = $1 - (↑n * 2 + 1) * ↑n * (↑n + 1) := by ring
                        _ ≤ 0 := by
                          apply sub_nonpos.mpr
                          ring_nf
                          rw [show (3 : ℝ) * (↑n + 1) ^ 3 = (↑n + 1) * (↑n + 1) * (↑n + 1) * 3 by ring]
                          apply mul_le_mul
                          · rw [mul_le_mul_right (by simp) (by simp)]
                            apply mul_le_mul (by simp) (by simp) (by simp) (by simp)
                          · norm_num
                rw [← mul_le_mul_iff_of_pos_right (by simp)]
                rw [mul_comm, mul_assoc, mul_assoc, ← mul_sub, ← mul_div_assoc]
                apply mul_le_mul
                · rw [mul_le_mul_right (by simp) (by simp)]
                  apply mul_le_mul (by simp) (by simp) (by simp) (by simp)
                · norm_num
              _ = (3 * (↑n + 1) ^ 3 - (↑n + 1) * (↑n + 1) * (↑n + 1) * 3) / ↑n / (↑n + 1) ^ 3 := by
                rw [div_mul_eq_div_div]
                norm_cast
                rw [add_mul, add_mul, mul_assoc, mul_assoc, mul_comm (↑n + 1) _, mul_assoc, mul_assoc]
                simp only [Nat.ofNat_pos, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
                  mul_eq_mul_right_iff, OfNat.ofNat_ne_zero, or_false]
                symm
                rw [mul_div_assoc, mul_div_assoc, div_self (by positivity), mul_one]
                simp only [Nat.ofNat_pos, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
                  mul_eq_mul_right_iff, OfNat.ofNat_ne_zero, or_false]
                apply Ne.symm
                apply OfNat.ofNat_ne_zero
              _ = _ := by
                rw [mul_div_assoc, mul_div_assoc, div_self (by positivity), mul_one]
                ring_nf
            all_goals
              positivity
      linarith only [ih2]
```