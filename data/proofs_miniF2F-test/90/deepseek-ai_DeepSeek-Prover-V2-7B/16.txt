have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn IH
    · norm_num -- Base case: when n = 1, the product is 1 + 1/1^3 = 2, and 3 - 1/1 = 2, so the inequality holds.
    · cases n with
      | zero => contradiction -- n cannot be zero since hn : 0 < n
      | succ n =>
        simp_all [Finset.prod_Icc_succ_top, Nat.div_eq_of_lt, Nat.lt_succ_self]
        refine' le_trans (mul_le_mul_of_nonneg_right IH _) _
        · norm_num -- Each term in the product is non-negative, so the product is non-negative.
        · norm_num
          apply le_of_sub_nonneg
          field_simp
          ring_nf
          positivity
  exact h₁ n h₀


theorem induction_prod1p1onk3le3m1onn' (n : ℕ) (h₀ : 0 < n) :
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
  have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn IH
    · norm_num -- Base case: when n = 1, the product is 1 + 1/1^3 = 2, and 3 - 1/1 = 2, so the inequality holds.
    · cases n with
      | zero => contradiction -- n cannot be zero since hn : 0 < n
      | succ n =>
        simp_all [Finset.prod_Icc_succ_top, Nat.div_eq_of_lt, Nat.lt_succ_self]
        refine' le_trans (mul_le_mul_of_nonneg_right IH _) _
        · norm_num -- Each term in the product is non-negative, so the product is non-negative.
        · norm_num
          apply le_of_sub_nonneg
          field_simp
          ring_nf
          positivity
  exact h₁ n h₀


theorem induction_prod1p1onk3le3m1onn'' (n : ℕ) (h₀ : 0 < n) :
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
  have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn IH
    · norm_num -- Base case: when n = 1, the product is 1 + 1/1^3 = 2, and 3 - 1/1 = 2, so the inequality holds.
    · cases n with
      | zero => contradiction -- n cannot be zero since hn : 0 < n
      | succ n =>
        simp_all [Finset.prod_Icc_succ_top, Nat.div_eq_of_lt, Nat.lt_succ_self]
        refine' le_trans (mul_le_mul_of_nonneg_right IH _) _
        · norm_num -- Each term in the product is non-negative, so the product is non-negative.