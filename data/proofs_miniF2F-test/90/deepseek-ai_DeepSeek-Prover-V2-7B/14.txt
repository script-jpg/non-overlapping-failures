have h₁ : ∀ k : ℕ, k ∈ Finset.Icc 1 n → (1 : ℝ) + 1 / k ^ 3 ≤ 2 := by
    intro k hk
    have hk' : k ≥ 1 := by
      simp only [Finset.mem_Icc] at hk
      linarith
    have hk'' : (k : ℝ) ≥ 1 := by exact_mod_cast hk'
    have hk''' : (1 : ℝ) / k ^ 3 ≤ 1 := by
      apply div_le_one_of_le
      exact_mod_cast Nat.one_le_pow _ _ hk'
      positivity
    linarith
  
  have h₂ : (∏ k in Finset.Icc 1 n, (1 : ℝ) + 1 / k ^ 3) ≤ ∏ k in Finset.Icc 1 n, 2 := by
    apply Finset.prod_le_prod
    · intro i hi
      positivity
    · intro i hi
      exact h₁ i hi
  
  have h₃ : (∏ k in Finset.Icc 1 n, (2 : ℝ)) = 2 ^ n := by
    simp [Finset.prod_const]
    <;> ring
  
  have h₄ : (∏ k in Finset.Icc 1 n, (2 : ℝ)) = 2 ^ n := by
    simp [Finset.prod_const]
    <;> ring
  
  have h₅ : (2 : ℝ) ^ n = 2 ^ n := by rfl
  
  have h₆ : (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ 2 ^ n := by
    calc
      (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ ∏ k in Finset.Icc 1 n, 2 := h₂
      _ = 2 ^ n := by simp [h₃, h₄, h₅]
  
  have h₇ : (2 : ℝ) ^ n ≤ 3 - 1 / ↑n := by
    have h₇ : ∀ n : ℕ, 0 < n → (2 : ℝ) ^ n ≤ 3 - 1 / ↑n := by
      intro n hn
      induction' hn with n hn
      · norm_num
      · cases n with
        | zero =>
          norm_num
        | succ n =>
          simp_all [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_succ]
          <;> norm_num <;>
            ring_nf at * <;>
            apply le_trans (by nlinarith) _ <;>
            field_simp <;>
            ring_nf <;>
            norm_num <;>
            apply le_of_sub_nonneg <;>
            field_simp <;>
            ring_nf <;>
            positivity
    exact h₇ n h₀
  
  have h₈ : (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    calc
      (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ 2 ^ n := h₆
      _ ≤ 3 - 1 / ↑n := h₇
  
  exact h₈
```