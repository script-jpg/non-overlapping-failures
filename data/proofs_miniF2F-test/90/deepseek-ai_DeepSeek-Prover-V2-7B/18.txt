have h₁ : ∀ k : ℕ, k ∈ Finset.Icc 1 n → (1 : ℝ) + 1 / k ^ 3 ≤ 2 := by
    intro k hk
    have hk' : k ≥ 1 := by
      simp only [Finset.mem_Icc] at hk
      linarith
    have hk'' : (k : ℝ) ≥ 1 := by exact_mod_cast hk'
    have h : (1 : ℝ) + 1 / k ^ 3 ≤ 2 := by
      have h₁ : (1 : ℝ) / k ^ 3 ≤ 1 := by
        have h₂ : (k : ℝ) ≥ 1 := by exact_mod_cast hk'
        rw [div_le_iff (by positivity)]
        nlinarith [pow_three k]
      nlinarith
    exact h
  
  have h₂ : (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (2 : ℝ)^n := by
    calc
      (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ ∏ k in Finset.Icc 1 n, 2 := Finset.prod_le_prod (fun k _ ↦ by
        have h₁ : (1 : ℝ) + 1 / k ^ 3 ≥ 1 := by
          have h₂ : (1 : ℝ) / k ^ 3 ≥ 0 := by positivity
          nlinarith
        nlinarith) (fun k hk ↦ by exact h₁ k hk)
      _ = 2 ^ n := by simp [Finset.prod_const]
  
  have h₃ : (2 : ℝ)^n ≤ (3 : ℝ) - 1 / ↑n := by
    have h₄ : ∀ n : ℕ, 0 < n → (2 : ℝ)^n ≤ (3 : ℝ) - 1 / n := by
      intro n hn
      induction' hn with n hn
      case refl => norm_num
      case step =>
        cases n with
        | zero => contradiction
        | succ n =>
          simp_all [pow_succ]
          norm_num
          apply le_trans (mul_le_mul_of_nonneg_right (by assumption) (by positivity))
          field_simp
          rw [div_le_div_iff] <;> norm_num <;>
          ring_nf <;>
          nlinarith [sq_nonneg (n : ℝ), sq_nonneg ((n : ℝ) + 1), sq_nonneg ((n : ℝ) - 1)]
    exact h₄ n h₀
  
  calc
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (2 : ℝ)^n := by exact h₂
    _ ≤ (3 : ℝ) - 1 / ↑n := by exact h₃
    _ = (3 : ℝ) - 1 / ↑n := by rfl
```