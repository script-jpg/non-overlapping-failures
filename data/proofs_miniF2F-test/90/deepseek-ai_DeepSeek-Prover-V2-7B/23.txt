have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn
    · norm_num
    · cases n with
      | zero =>
        norm_num
      | succ n =>
        rw [Finset.prod_Icc_succ_top (by norm_num : 1 ≤ n.succ)]
        refine'
          le_trans (mul_le_mul_of_nonneg_right (by assumption) (by positivity)) _
        cases n with
        | zero =>
          norm_num
        | succ n =>
          simp_all [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one, Nat.cast_pow]
          refine' le_trans (add_le_add_right (by assumption) _) _
          norm_num
          apply le_of_sub_nonneg
          field_simp
          ring_nf
          positivity
  exact h₁ n h₀

theorem induction_prod1p1onk3le3m1onn' (n : ℕ) (h₀ : 0 < n) :
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
  have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn
    · norm_num
    · cases n with
      | zero =>
        norm_num
      | succ n =>
        rw [Finset.prod_Icc_succ_top (by norm_num : 1 ≤ n.succ)]
        refine'
          le_trans (mul_le_mul_of_nonneg_right (by assumption) (by positivity)) _
        cases n with
        | zero =>
          norm_num
        | succ n =>
          simp_all [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one, Nat.cast_pow]
          refine' le_trans (add_le_add_right (by assumption) _) _
          norm_num
          apply le_of_sub_nonneg
          field_simp
          ring_nf
          positivity
  exact h₁ n h₀

theorem induction_prod1p1onk3le3m1onn'' (n : ℕ) (h₀ : 0 < n) :
    (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
  have h₁ : ∀ n : ℕ, 0 < n → (∏ k in Finset.Icc 1 n, 1 + (1 : ℝ) / k ^ 3) ≤ (3 : ℝ) - 1 / ↑n := by
    intro n hn
    induction' hn with n hn
    · norm_num
    · cases n with
      | zero =>
        norm_num
      | succ n =>
        rw [Finset.prod_Icc_succ_top (by norm_num : 1 ≤ n.succ)]
        refine'
          le_trans (mul_le_mul_of_nonneg_right (by assumption) (by positivity)) _
        cases n with
        | zero =>
          norm_num
        | succ n =>
          simp_all [Finset.prod_Icc_succ_top, Nat.cast_add, Nat.cast_one, Nat.cast_pow]
          refine' le_trans (add_le_add_right (by assumption) _) _
          norm_num
          apply le