have step1 : S.card = 6 := by
    have h₁ : S = {144, 441, 1156, 2209, 3844, 6241} := by
      ext n
      simp only [h₀, Finset.mem_insert, Finset.mem_singleton, eq_self_iff_true, and_true]
      constructor
      · intro h
        have h₂ : 0 < n := by aesop
        have h₃ : ((n : ℝ) + 1000) / 70 = Int.floor (Real.sqrt n) := by aesop
        have h₄ : Int.floor (Real.sqrt n) = Int.floor (Real.sqrt n) := rfl
        have h₅ : (n : ℝ) ≥ 0 := by positivity
        have h₆ : Real.sqrt n ≥ 0 := Real.sqrt_nonneg n
        have h₇ : Int.floor (Real.sqrt n) ≤ Real.sqrt n := Int.floor_le (Real.sqrt n)
        have h₈ : Real.sqrt n < Int.floor (Real.sqrt n) + 1 := by
          apply Int.lt_floor_add_one
        have h₉ : ((n : ℝ) + 1000) / 70 = Int.floor (Real.sqrt n) := by aesop
        have h₁₀ : n ≤ 10000 := by
          by_contra h
          have : n ≥ 10001 := by linarith
          have : Real.sqrt n ≥ Real.sqrt 10001 := by
            apply Real.sqrt_le_sqrt
            norm_num at * <;> nlinarith
          have : Real.sqrt 10001 > 100 := by
            apply Real.lt_sqrt_of_sq_lt
            norm_num
            <;> nlinarith
          have : Int.floor (Real.sqrt n) ≥ 100 := by
            apply Int.le_floor.mpr
            norm_num at * <;>
            nlinarith
          field_simp at h₉
          rw [Int.cast_inj] at h₉
          norm_num at *
          nlinarith [Real.sq_sqrt (by positivity : (0 : ℝ) ≤ n), Real.sqrt_nonneg n, Real.sq_sqrt (by positivity : (0 : ℝ) ≤ (10001 : ℝ))]
        interval_cases n <;> norm_num [Int.floor_eq_iff, Real.sqrt_lt, Real.lt_sqrt, Real.sqrt_le_iff] at h₃ h₉ ⊢ <;>
          (try { nlinarith }) <;>
          (try {
            norm_num at * <;>
            (try {
              rcases h₉ with ⟨h₉, _⟩ <;>
              norm_cast at * <;>
              ring_nf at * <;>
              nlinarith
            }) <;>
            (try {
              norm_cast at * <;>
              ring_nf at * <;>
              nlinarith
            }) <;>
            aesop
          }) <;>
          aesop
      · intro h
        rcases h with (rfl | rfl | rfl | rfl | rfl | rfl) <;>
        norm_num [Int.floor_eq_iff, Real.sqrt_lt, Real.lt_sqrt, Real.sqrt_le_iff] <;>
        (try {
          norm_num
          <;>
          (try {
            norm_cast
            <;>
            ring_nf
            <;>
            norm_num [Int.floor_eq_iff, Real.sqrt_lt, Real.lt_sqrt, Real.sqrt_le_iff] at * <;>
            (try {
              norm_num at * <;>
              nlinarith [Real.sqrt_nonneg 144, Real.sq_sqrt (by positivity : (0 : ℝ) ≤ (144 : ℝ)),
                Real.sqrt_nonneg