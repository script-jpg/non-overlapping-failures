have step₁ : S.card = 19 := by
      have : S = Finset.Ioo (-9 : ℤ) 10 := by
        ext x
        simp only [h₀, Finset.mem_Ioo, abs_lt, Int.cast_lt]
        constructor
        -- First direction: if x is in S, then -9 < x < 10
        · intro h
          have h₁ : (x : ℝ) < 3 * Real.pi := by
            simp_all [abs_lt] <;>
            nlinarith [Real.pi_gt_three, Real.pi_le_four]
          have h₂ : - (3 * Real.pi) < (x : ℝ) := by
            simp_all [abs_lt] <;>
            nlinarith [Real.pi_gt_three, Real.pi_le_four]
          have h₃ : -9 < x := by
            by_contra! h₄
            have : x ≤ -9 := by linarith
            have : (x : ℝ) ≤ -9 := by exact_mod_cast this
            nlinarith [Real.pi_gt_three, Real.pi_le_four, Real.pi_pos, Real.pi_le_four]
          have h₄ : x < 10 := by
            by_contra! h₅
            have : x ≥ 10 := by linarith
            have : (x : ℝ) ≥ 10 := by exact_mod_cast this
            nlinarith [Real.pi_gt_three, Real.pi_le_four, Real.pi_pos, Real.pi_le_four]
          exact ⟨h₃, h₄⟩
        -- Second direction: if -9 < x < 10, then x is in S
        · rintro ⟨h₁, h₂⟩
          have h₃ : (x : ℝ) < 3 * Real.pi := by
            nlinarith [Real.pi_gt_three, Real.pi_le_four, Real.pi_pos, Real.pi_le_four]
          have h₄ : - (3 * Real.pi) < (x : ℝ) := by
            nlinarith [Real.pi_gt_three, Real.pi_le_four, Real.pi_pos, Real.pi_le_four]
          simp_all [abs_lt] <;>
          norm_num <;>
          cases' le_total 0 (x : ℝ) with h₅ h₅ <;>
          simp_all [abs_of_nonneg, abs_of_nonpos, h₅] <;>
          nlinarith [Real.pi_gt_three, Real.pi_le_four, Real.pi_pos, Real.pi_le_four]
      rw [this]
      rfl
    exact step₁