have h₂ : a ^ 2 % 8 = 1 := by
    -- 4 ∣ b
    rcases h₁ with ⟨c, hc⟩
    -- b = 4c
    rw [hc, show (4 * c ^ 2 + a ^ 2) % 8 = (a ^ 2 + 4 * c ^ 2) % 8 by ring_nf]
    -- use b^2 = 16 * (c^2 * d^2 + c^2 + d^2) + 4 * c^2
    have : a ^ 2 % 8 = 1 := by
      obtain ⟨d, hd⟩ := h₀
      -- a = 2d + 1
      rw [hd, ←Int.two_mul, ←Int.add_zero 1]
      simp
      obtain ⟨k, hk⟩ := Int.even_iff.1 <| ((show Odd (2 * d + 1) by simp [Int.odd_iff]) ▸ hd)
      -- k = 2 * t
      obtain ⟨t, ht⟩ := even_iff_two_dvd.mp hk
      rw [ht, show (t ^ 2 * 4 + t ^ 2 * 8) % 8 = (t ^ 2 * 4 + (t ^ 2 * 8 % 8)) % 8 by apply Int.add_mod]
      simp
      norm_num
      rw [Int.add_mul_emod_self_left]
      norm_num
    assumption

  obtain ⟨c, hc⟩ := h₁
  -- b = 4c
  rw [hc, show (4 * c ^ 2 + a ^ 2) % 8 = (a ^ 2 + 4 * c ^ 2) % 8 by ring_nf]
  -- use b^2 = 16 * (c^2 * d^2 + c^2 + d^2) + 4 * c^2
  have : b ^ 2 % 8 = 0 := by
    rw [hc, ←Int.ofNat_pow, Int.mul_emod_self, Int.mul_emod_self, Int.mul_emod_self, Int.mul_emod_self]
    norm_num
  rw [show (a ^ 2 + 4 * c ^ 2) % 8 = ((a ^ 2 % 8) + (4 * c ^ 2 % 8)) % 8 by apply Int.add_mod]
  simp
  norm_num
  omega
```