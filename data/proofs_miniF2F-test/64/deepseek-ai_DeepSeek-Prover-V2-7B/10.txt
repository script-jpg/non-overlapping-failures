have h₄ : (∑ k in (Set.range h).toFinset, k) = 12 := by
    have h₅ : Set.range h = {1, 12} := by
      ext x
      simp only [Set.mem_range, Set.mem_insert_iff, Set.mem_singleton_iff, h₂, h₀, h₁,
        Nat.gcd_comm]
      constructor
      · intro h₆
        obtain ⟨x, rfl⟩ := h₆
        have h₇ : x ≥ 1 := x.prop
        have h₈ : Nat.gcd (12 * x + 7) (5 * x + 2) = 1 ∨ Nat.gcd (12 * x + 7) (5 * x + 2) = 12 := by
          have h₉ : Nat.gcd (12 * x + 7) (5 * x + 2) = 1 ∨ Nat.gcd (12 * x + 7) (5 * x + 2) = 12 := by
            have h₁₀ : Nat.gcd (12 * x + 7) (5 * x + 2) ∣ 12 * x + 7 := Nat.gcd_dvd_left (12 * x + 7) (5 * x + 2)
            have h₁₁ : Nat.gcd (12 * x + 7) (5 * x + 2) ∣ 5 * x + 2 := Nat.gcd_dvd_right (12 * x + 7) (5 * x + 2)
            have h₁₂ : Nat.gcd (12 * x + 7) (5 * x + 2) ≤ 12 * x + 7 := Nat.le_of_dvd (by nlinarith) h₁₀
            have h₁₃ : Nat.gcd (12 * x + 7) (5 * x + 2) ≤ 5 * x + 2 := Nat.le_of_dvd (by nlinarith) h₁₁
            have h₁₄ : Nat.gcd (12 * x + 7) (5 * x + 2) = 1 ∨ Nat.gcd (12 * x + 7) (5 * x + 2) = 12 := by
              interval_cases Nat.gcd (12 * x + 7) (5 * x + 2) <;> omega
            exact h₁₄
          exact h₉
        rcases h₈ with (h₈ | h₈) <;> simp_all [h₈] <;> omega
      · intro h₆
        rcases h₆ with (rfl | rfl)
        · use 1
          simp [h₀, h₁, h₂, Nat.gcd_one_right]
        · use 2
          simp [h₀, h₁, h₂, Nat.gcd_eq_right]
          <;> norm_num
          <;> ring_nf
          <;> norm_num
          <;> omega
    simp [h₅]
    <;> norm_num
    <;> rfl
  
  exact h₄
```