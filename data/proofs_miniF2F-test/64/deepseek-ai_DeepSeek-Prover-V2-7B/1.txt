have h₄ : (∑ k in (Set.range h).toFinset, k) = 12 := by
    have : Set.range h = {1, 12} := by
      ext x
      simp only [Set.mem_range, Set.mem_insert_iff, Set.mem_singleton_iff, h₂, h₀, h₁,
        Nat.gcd_comm]
      constructor
      · intro h
        match x with
        | ⟨1, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨2, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨3, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨4, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨5, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨6, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨7, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨8, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨9, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨10, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨11, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | ⟨12, _⟩ =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
      · intro h
        match h with
        | Or.inl h =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
        | Or.inr h =>
          simp_all [Nat.gcd_eq_right]
          <;> norm_num
          <;> aesop
    simp_all [Finset.sum_pair]
    <;> norm_num
    <;> aesop
  
  exact h₄
```