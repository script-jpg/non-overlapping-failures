have A (n : ℕ) : (3 ^ 2 ^ n - 1) % 2 ^ (n + 2) = 2 ^ n := by
    induction n with
    | zero => simp
    | succ n ih =>
      rw [pow_add, pow_one, mul_comm, pow_succ, pow_two, Nat.add_sub_assoc, Nat.add_sub_cancel]
      rw [pow_succ, Nat.mul_mod, ih, Nat.pow_mod]
      have : 2 ^ n < 2 ^ (n + 1) := Nat.pow_lt_pow_of_lt (by omega) (by omega)
      rw [Nat.mod_eq_of_lt this, Nat.sub_add_cancel (by omega)]
      have : 2 ^ (n + 1) < 2 ^ (n + 2) := Nat.pow_lt_pow_of_lt (by omega) (by omega)
      rw [Nat.mod_eq_of_lt this, Nat.add_sub_cancel (by omega)]

  have B (n : ℕ) : (3 ^ 2 ^ n - 1) % 2 ^ (n + 3) = 2 ^ (n + 1) := by
    rw [show 2 ^ (n + 3) = 2 ^ (n + 1) * 4 by ring]
    rw [Nat.mod_eq_of_dvd]
    have : 2 ^ (n + 1) ∣ 3 ^ 2 ^ n - 1 := by
      have : 2 ^ (n + 1) ∣ 2 ^ n * 2 ^ (n + 2) := by
        convert Nat.mul_dvd_mul_left _ (Nat.pow_dvd_pow 2 (by omega))
        omega
      rw [Nat.pow_dvd_pow 2 (by omega)] at this
      convert this using 1
      ring
    exact Nat.mod_eq_of_dvd this rfl

  have C : (3 ^ 2 ^ n - 1) % 2 ^ (n + 3) = 2 ^ (n + 2) := by
    have : (3 ^ 2 ^ n - 1) % 2 ^ (n + 3) = 2 ^ (n + 1) := B n
    rw [this]
    have : 2 ^ (n + 1) = 2 ^ (n + 2) / 2 := by omega
    rw [this]
    have : 2 ^ (n + 2) / 2 = 2 ^ (n + 2) * (1 / 2) := by omega
    rw [this]
    omega

  exact C
```