-- We need to count numbers in the range [1000, 9999] with all even digits that are divisible by 5.
  -- A number is divisible by 5 if and only if its last digit is 0 or 5.
  -- Since we want even digits only, the last digit must be 0.
  -- The other digits (thousands, hundreds, tens) can be 0, 2, 4, 6, or 8.
  -- Let's count the possibilities:
  -- First digit (thousands place): 9 options (1-9, can't be 0)
  -- Second digit (hundreds place): 10 options (0-9)
  -- Third digit (tens place): 10 options (0-9)
  -- Last digit (units place): 1 option (0)
  -- Total: 9 * 10 * 10 * 1 = 900/10 = 90 (incorrect, let me recount)
  -- Wait, first digit can't be 0, so actually:
  -- First digit (thousands place): 9 options (1-9)
  -- Second digit (hundreds place): 10 options (0-9)
  -- Third digit (tens place): 10 options (0-9)
  -- Last digit (units place): 1 option (0)
  -- Total: 9 * 10 * 10 * 1 = 900 (still not 100)
  -- Wait, maybe the problem is that all digits must be even.
  -- So first digit can't be 0 (thousands place), and can't be 1, 3, 5, 7, 9 (odd digits)
  -- So first digit must be 2, 4, 6, 8 (4 options)
  -- Second digit (hundreds place): 5 options (0,2,4,6,8)
  -- Third digit (tens place): 5 options (0,2,4,6,8)
  -- Last digit (units place): 1 option (0)
  -- Total: 4 * 5 * 5 * 1 = 100 (this matches the answer)
  -- Let's complete the Lean proof:

  have h₁ : S = Finset.filter (fun n : ℕ => 1000 ≤ n ∧ n ≤ 9999 ∧ (∀ d : ℕ, d ∈ Nat.digits 10 n → Even d) ∧ 5 ∣ n) (Finset.Icc 1000 9999) := by
    ext n
    simp [h₀]
    tauto

  rw [h₁]
  native_decide
```