--  .set_option maxRecDepth 10000 in this proof is used to solve the problem of reciprocal depth in Lean 4's recursion.
 .set_option maxRecDepth 10000 in native_decide

  -- show that the sum of the positive divisors of 500 is 992
  have ha : a = 992 := by
    norm_num [h₀]
    -- the divisor of 500 is 1, 2, 4, 5, 10, 20, 25, 50, 100, 125, 250, 500
    have : Nat.divisors 500 = {1, 2, 4, 5, 10, 20, 25, 50, 100, 125, 250, 500} := by
      -- here we use the condition that for any n, m, we have n ∨ m ∈ Nat.divisors 500 ↔ n * m ∈ Nat.divisors 500
      apply Nat.eq_divisors_iff_sub properDivisors (by norm_num)
      -- check the condition for 1 to 500
      native_decide
    -- so the sum of divisors of 500 is 992
    rw [this, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert,
        Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert,
        Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton]
    repeat rw [Finset.sum_singleton]
    all_goals norm_num

  -- show that the sum of the distinct prime divisors of 992 is 25
  show that (∑ k in Finset.filter (fun x => Nat.Prime x) (Nat.divisors 992), k) = 25
  -- the divisor of 992 is 1, 2, 4, 8, 16, 31, 32, 62, 124, 248, 496, 992
  have : Nat.divisors 992 = {1, 2, 4, 8, 16, 31, 32, 62, 124, 248, 496, 992} := by
    -- here we use the condition that for any n, m, we have n ∨ m ∈ Nat.divisors 500 ↔ n * m ∈ Nat.divisors 500
    apply Nat.eq_divisors_iff_sub properDivisors (by norm_num)
    -- check the condition for 1 to 500
    native_decide
  -- so the sum of prime divisors of 992 is 25
  rw [this, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert,
      Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_insert,
      Finset.sum_insert, Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton]
  repeat rw [Finset.sum_singleton]
  all_goals norm_num
```