constructor
  · intro h
    have h₁ := h 0 0
    have h₂ := h 0 1
    have h₃ := h 1 0
    have h₄ := h 1 1
    have h₅ := h 2 0
    have h₆ := h 1 (-1)
    have h₇ := h 2 1
    have h₈ := h (-1) 1
    have h₉ := h 0 (-1)
    have h₁₀ := h 2 (-1)
    have h₁₁ := h (-1) (-1)
    simp at h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ h₁₁
    have h₁₂ : f 0 = 0 := by
      omega
    have h₁₃ : ∀ z, f z = 0 ∨ ∃ c, ∀ z, f z = 2 * z + c := by
      intro z
      by_cases hz : f z = 0
      · exact Or.inl hz
      · right
        use (f z - 2 * z)
        intro z'
        have h₁₄ := h z' 0
        have h₁₅ := h z' z
        have h₁₆ := h (z + z') 0
        have h₁₇ := h (z + z') z
        have h₁₈ := h 0 (z + z')
        have h₁₉ := h z (z + z')
        have h₂₀ := h 0 (-z)
        have h₂₁ := h z (-z)
        have h₂₂ := h (-z) z
        have h₂₃ := h (-z) (-z)
        simp [hz, h₁₂] at h₁₄ h₁₅ h₁₆ h₁₇ h₁₈ h₁₉ h₂₀ h₂₁ h₂₂ h₂₃
        <;> ring_nf at *
        <;> omega
    exact h₁₃
  · intro h
    rcases h with (h | ⟨c, h⟩)
    · intro a b
      have h₁ := h 0
      have h₂ := h 1
      have h₃ := h (-1)
      have h₄ := h 2
      have h₅ := h (-2)
      simp at h₁ h₂ h₃ h₄ h₅
      <;> omega
    · intro a b
      have h₁ := h a
      have h₂ := h b
      have h₃ := h (a + b)
      have h₄ := h (2 * a)
      have h₅ := h (2 * b)
      simp [h, mul_add, add_mul, mul_comm, mul_left_comm] at *
      <;> ring_nf at *
      <;> omega

theorem imo_2019_p1_specific_solution (f : ℤ → ℤ) :
    (∀ a b, f (2 * a) + 2 * f b = f (f (a + b))) ↔ ∀ z, f z = 0 ∨ ∃ c, ∀ z, f z = 2 * z + c := by
  constructor
  · intro h
    have h₁ := h 0 0
    have h₂ := h 0 1
    have h₃ := h 1 0
    have h₄ := h 1 1
    have h₅ := h 2 0
    have h₆ := h 1 (-1)
    have h₇ := h 2 1
    have h₈ := h (-1) 1
    have h₉ := h 0 (-1)
    have h₁₀ := h 2 (-1)
    have h₁₁ := h (-1) (-1)
    simp at h₁ h₂ h₃ h₄ h₅ h₆ h₇ h₈ h₉ h₁₀ h₁₁
    have h₁₂ : f 0 = 0 := by