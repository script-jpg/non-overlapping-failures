have step₁ : x > 0 := by linarith
  have step₂ : y > 0 := by linarith
  have step₃ : z > 0 := by linarith
  have step₄ : Real.log x ≠ 0 := by
    intro h
    have h' : Real.log x = 0 := by simpa using h
    have h'' : x = 1 := by
      rw [← Real.exp_log (by positivity : (x : ℝ) > 0)]
      simp [h']
    simp_all
    <;> nlinarith
  have step₅ : Real.log y ≠ 0 := by
    intro h
    have h' : Real.log y = 0 := by simpa using h
    have h'' : y = 1 := by
      rw [← Real.exp_log (by positivity : (y : ℝ) > 0)]
      simp [h']
    simp_all
    <;> nlinarith
  have step₆ : Real.log z ≠ 0 := by
    intro h
    have h' : Real.log z = 0 := by simpa using h
    have h'' : z = 1 := by
      rw [← Real.exp_log (by positivity : (z : ℝ) > 0)]
      simp [h']
    simp_all
    <;> nlinarith
  have step₇ : Real.log w / Real.log x = 24 := by assumption
  have step₈ : Real.log w / Real.log y = 40 := by assumption
  have step₉ : Real.log w / Real.log (x * y * z) = 12 := by assumption
  have step₁₀ : Real.log (x * y * z) = Real.log x + Real.log y + Real.log z := by
    rw [Real.log_mul (by positivity) (by positivity), Real.log_mul (by positivity) (by positivity)]
    <;> positivity
  have step₁₁ : Real.log w / (Real.log x + Real.log y + Real.log z) = 12 := by
    simp_all [step₁₀] <;> ring_nf at * <;> nlinarith
  have step₁₂ : Real.log w / Real.log z = 60 := by
    field_simp [step₄, step₅, step₆] at *
    ring_nf at *
    <;> nlinarith [sq_nonneg (Real.log x + Real.log y),
      sq_nonneg (Real.log x - Real.log y),
      Real.log_mul (by positivity : (x : ℝ) ≠ 0) (by positivity : (y : ℝ) ≠ 0),
      Real.log_mul (by positivity : (x : ℝ) ≠ 0) (by positivity : (z : ℝ) ≠ 0),
      Real.log_mul (by positivity : (y : ℝ) ≠ 0) (by positivity : (z : ℝ) ≠ 0)]
  exact_mod_cast step₁₂
```