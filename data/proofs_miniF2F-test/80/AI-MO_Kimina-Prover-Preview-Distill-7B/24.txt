-- auxiliary lemma : for positive x, y, z, we have x / sqrt (x + y) + y / sqrt (y + z) + z / sqrt (z + x)
  -- ≤ 3 / sqrt (8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z)))
  -- ≤ 3 / sqrt (2).
  have aux {x y z : ℝ} (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) :
    x / Real.sqrt (x + y) + y / Real.sqrt (y + z) + z / Real.sqrt (z + x)
    ≤ 3 / Real.sqrt (8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))) ∧
    3 / Real.sqrt (8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))) ≤ 3 / Real.sqrt 2 := by
    have : 8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z)) ≥ 2 := by
      calc
        8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))
        _ = 8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z)) := by rfl
        _ ≥ 8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z)) := by
          apply mul_le_mul_of_nonneg_left
          norm_num
          apply add_le_add
          apply add_le_add
          apply add_le_add
          apply add_le_add
          norm_num
          all_goals positivity
        _ = 2 := by
          rw [div_eq_mul_inv, mul_comm, ← mul_div_assoc, mul_div_cancel_left₀ _ (by positivity), mul_one, div_eq_mul_inv, ← mul_assoc, mul_inv_cancel₀ _ (by positivity), mul_one]
          nth_rw 2 [mul_comm]
          rw [div_eq_mul_inv, ← mul_assoc, mul_inv_cancel₀ _ (by positivity), mul_one, div_eq_mul_inv, ← mul_assoc, mul_inv_cancel₀ _ (by positivity), mul_one, div_eq_mul_inv, ← mul_assoc, mul_inv_cancel₀ _ (by positivity), mul_one]
          calc
            8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))
            _ = 8 / 3 * (1 / 3 * x + 1 / 3 * y + 1 / 3 * z + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z)) := by ring
            _ = 8 / 3 * (1 / 3 * x + 1 / 3 * y + 1 / 3 * z + 1 / 2 * x / y + 1 / 2 * y / x + 1 / 2 * y / z + 1 / 2 * z / y + 1 / 2 * z / x + 1 / 2 * x / z) := by ring
            _ = 8 / 3 * (1 / 3 * x + 1 / 3 * y + 1 / 3 * z + 1 / 2 * x / y + 1 / 2 * y / x + 1 / 2 * y / z + 1 / 2 * z / y + 1 / 2 * z / x + 1 / 2 * x / z) := by norm_num
            _ = 2 := by
              field_simp
              rw [mul_div_cancel_left₀]
              have : (2 * (x * y * z) * (x * y * z) * (1 / 2) * (1 / 2) * (1 / 3) * (1 / 3) * (1 / 3) * (x + y + z) * (x + y + z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z) * (x * y * z) * (1 / 2) * (1 / 2) * (1 / 2) * (x * y * z) * (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z) * (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3)) = (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3) * (x + y + z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z) * (1 / 2) * (1 / 2) * (1 / 2) * (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z) * (1 / 3) * (1 / 3) * (1 / 3) * (x * y * z)] := by
                apply (mul_div_cancel_left₀ _ (by positivity)).trans
                rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
                apply (mul_div_cancel_left₀ _ (by positivity)).trans
                rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc]
                apply (mul_div_cancel_left₀ _ (by positivity)).trans
                rw [mul_assoc, mul_assoc, mul_assoc]
                apply (mul_div_cancel_left₀ _ (by positivity)).trans
                rw [mul_assoc, mul_assoc]
                apply (mul_div_cancel_left₀ _ (by positivity)).trans
                rw [mul_assoc]
                trans
               . rw [mul_assoc, mul_comm, mul_assoc, mul_assoc]
                  ring
               . rw [mul_assoc, mul_comm x, mul_assoc, mul_assoc]
                  ring
               . rw [mul_comm]
                  ring
              rw [this]
              apply (mul_div_cancel_left₀ _ (by positivity)).trans
              rw [mul_assoc, mul_comm, mul_assoc, mul_assoc]
              ring
    have aux₁ : x / Real.sqrt (x + y) + y / Real.sqrt (y + z) + z / Real.sqrt (z + x)
      ≤ 3 / Real.sqrt (8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))) := by
      apply le_trans _ this
      apply (div_le_div_iff_of_pos_right (by positivity)).mpr
      apply (div_le_div_iff_of_pos_right (by positivity)).mpr
      linarith only [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x)]
    have aux₂ : 3 / Real.sqrt (8 / 3 * (1 / 3 * (x + y + z) + 1 / 2 * (x / y + y / x) + 1 / 2 * (y / z + z / y) + 1 / 2 * (z / x + x / z))) ≤ 3 / Real.sqrt 2 := by
      apply div_le_div_of_le₀
      apply (mul_le_mul_left (by positivity)).mpr
      linarith only [this]
      all_goals positivity
    tauto

  -- Apply the above lemma to a, b, c
  have ⟨_, h₁'⟩ := aux h₀.1 h₀.2.1 h₀.2.2

  -- We show that 3 / sqrt (8 / 3 * (1 / 3 * (a + b + c) + 1 / 2 * (a / b + b / a) + 1 / 2 * (b / c + c / b) + 1 / 2 * (c / a + a / c))) ≤ 3 / sqrt 2.
  have h₂' : 3 / Real.sqrt (8 / 3 * (1 / 3 * (a + b + c) + 1 / 2 * (a / b + b / a) + 1 / 2 * (b / c + c / b) + 1 / 2 * (c / a + a / c))) ≤ 3 / Real.sqrt 2 := by
    apply div_le_div_of_le₀
    apply (mul_le_mul_left (by positivity)).mpr
    linarith only [h₁]
    all_goals positivity

  -- So it suffices to show that 3 / sqrt (8 / 3 * (1 / 3 * (a + b + c) + 1 / 2 * (a / b + b / a) + 1 / 2 * (b / c + c / b) + 1 / 2 * (c / a + a / c))) ≤ 3 / sqrt 2.
  have h₃ : 3 / Real.sqrt (8 / 3 * (1 / 3 * (a + b + c) + 1 / 2 * (a / b + b / a) + 1 / 2 * (b / c + c / b) + 1 / 2 * (c / a + a / c))) ≤ 3 / Real.sqrt 2 := by
    apply div_le_div_of_le₀
    apply (mul_le_mul_left (by positivity)).mpr
    linarith only [h₁]
    all_goals positivity

  -- Now we prove that 3 ≤ a / sqrt (a + b) + b / sqrt (b + c) + c / sqrt (c + a).
  have h₄ : 3 ≤ a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) := by
    -- Use the Cauchy-Schwarz inequality to prove that 3 / (sqrt (a + b) * sqrt (b + c) * sqrt (c + a)) ≤ a / sqrt (a + b) + b / sqrt (b + c) + c / sqrt (c + a).
    have h₄_aux : 3 / (Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a)) ≤ a / Real.sqrt (a + b) + b / Real.sqrt (b + c) + c / Real.sqrt (c + a) := by
      -- Apply the Cauchy-Schwarz inequality to the two sequences
      -- (sqrt (a / sqrt (a + b)), sqrt (b / sqrt (b + c)), sqrt (c / sqrt (c + a))) and (sqrt (a + b), sqrt (b + c), sqrt (c + a)).
      -- First, we need to prove that they are non-negative.
      have h₀' : ∀ x ∈ ({a, b, c} : Finset ℝ), 0 ≤ (x / Real.sqrt (x + y) : ℝ) := by
        intro x hx
        simp at hx
        rcases hx with (rfl | rfl | rfl)
        all_goals
          positivity
      have h₁' : ∀ x ∈ ({a, b, c} : Finset ℝ), 0 ≤ Real.sqrt (x + y) := by
        intro x hx
        simp at hx
        rcases hx with (rfl | rfl | rfl)
        all_goals
          positivity
      -- Apply the Cauchy-Schwarz inequality.
      have := Finset.sum_sq_le_sum_mul_of_sq_eq_mul ((by simp : {a, b, c} = Finset.image (fun x => x / Real.sqrt (x + y)) ({a, b, c} : Finset ℝ)) {a, b, c} (fun x => Real.sqrt (x + y)))
      simp [Finset.sum, h₀', h₁'] at this
      -- Now simplify the two sides of the inequality.
      rw [← Finset.sum_div Finset.image (fun x => x / Real.sqrt (x + y)) {a, b, c} (fun x => Real.sqrt (x + y))] at this
      nth_rw 2 [← Finset.sum_div Finset.image (fun x => Real.sqrt (x + y)) {a, b, c} (fun x => Real.sqrt (x + y))] at this
      rw [Finset.sum_congr rfl (by simp)] at this
      simp [Finset.sum] at this
      have : (Real.sqrt (a + b) * Real.sqrt (b + c) * Real.sqrt (c + a)) ^ 2 = (Real.sqrt (a + b) * Real.sqrt (b + c)) ^ 2 * (Real.sqrt (c + a)) ^ 2 := by ring
      rw [this]
      rw [mul_pow, Real.sq_sqrt (by positivity), mul_pow, Real.sq_sqrt (by positivity), Real.sq_sqrt (by positivity)]
      clear this
      -- Now we can simplify the inequality to a * b + b * c + c * a ≤ (a + b) * (b + c) * (c + a).
      rw [div_pow, div_pow, div_le_div_iff_of_pos_right (by positivity), ← pow_le_pow_iff_left₀ _ _ (by norm_num)]
      ring_nf
      rw [mul_comm, ← mul_assoc, mul_assoc, mul_comm (b * c), ← mul_assoc, mul_assoc, mul_assoc, mul_comm a]
      rw [mul_assoc, mul_comm (c * a), ← mul_assoc, mul_assoc, mul_assoc, mul_comm b]
      rw [mul_assoc, mul_comm (a * b), ← mul_assoc, mul_assoc, mul_assoc, mul_comm c]
      rw [mul_assoc, mul_assoc, mul_assoc, ← mul_assoc]
      rw [mul_assoc, mul_assoc, -]
      rw [mul_assoc, mul_assoc, mul_comm ((b + a) * c), -]
      rw [mul_assoc, mul_comm ((a + c) * b), -, mul_add, mul_comm (b * c), mul_assoc]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_add, mul_add, -]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_add, mul_add, mul_add, -]
      simp
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      rw [← mul_assoc, mul_comm (a * b), mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_comm (b * c), mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_comm (c * a), -]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_comm (a * b), mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_comm (b * c), mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_comm (c * a)]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      rw [mul_comm a, mul_comm b, mul_comm c]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      ring_nf
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      ring_nf
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      rw [mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc, mul_assoc]
      simp
      -- Use the AM-GM inequality to prove that (a + b) * (b + c) * (c + a ≥ 8 * a * b * c.