-- we get : b = 6 * a ^ 2 / 54 = a ^ 2 / 9.
  have h₃ : b = a ^ 2 / 9 := by
    calc
      _ = 6 * b / 6 := by ring_nf
      _ = a ^ 2 / 6 := by rw [h₁]
      _ = a ^ 2 / 9 := by ring_nf

  -- Substituting b = a ^ 2 / 9 into a ^ 2 = 6 * b, we get a ^ 2 = 6 * (a ^ 2 / 9) = (2 / 3) * a ^ 2
  have h₄ : a ^ 2 = (2 / 3) * a ^ 2 := by
    calc
      _ = 6 * b := h₁
      _ = 6 * (a ^ 2 / 9) := by rw [h₃]
      _ = (2 / 3) * a ^ 2 := by ring_nf

  -- Therefore, a = 0 or a ^ 2 = 0. But a > 0, so a ^ 2 > 0, and we must have a = 3 * sqrt (2 / 3).
  have h₅ : a = 3 * NNReal.sqrt (2 / 3) := by
    apply_fun fun t => t ^ 2 at h₄
    rw [sq_eq_sq₀ h₀.1] at h₄
    ring_nf at h₄
    field_simp at h₄
    rw [←Real.sqrt_eq_iff_eq_sq] at h₄
    rify at h₄ ⊢
    linarith only [h₄]

  -- Finally, note that 3 * sqrt (2 / 3) = 3 * sqrt 2 * sqrt (1 / 3) = 3 * sqrt 2 * 1 / sqrt 3 = 3 * sqrt 2 * sqrt 3 / 3 = sqrt (9 * 3) * sqrt 2 / 3
  --  = sqrt (3 ^ 2 * 3) * sqrt 2 / 3 = sqrt (3 ^ 2) * sqrt 3 * sqrt 2 / 3 = 3 * sqrt 3 * sqrt 2 / 3  = sqrt 3 * sqrt 2 = sqrt (3 * 2) = sqrt 6.
  rify at h₅ ⊢
  rw [h₅]
  rw [←Real.sqrt_mul (by linarith only)]
  push_cast
  rw [Real.sqrt_eq_iff_eq_sq (by positivity) (by positivity)]
  ring_nf
  field_simp
  norm_num
```